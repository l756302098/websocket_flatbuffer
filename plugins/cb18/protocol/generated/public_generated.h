// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PUBLIC_SWR_H_
#define FLATBUFFERS_GENERATED_PUBLIC_SWR_H_

#include "flatbuffers/flatbuffers.h"

namespace swr {

struct ErrorCode;
struct ErrorCodeBuilder;

struct FaultCode;

struct LockFaultCode;
struct LockFaultCodeBuilder;

struct Switch;
struct SwitchBuilder;

struct RouteIdent;
struct RouteIdentBuilder;

struct TeachCleanParam;
struct TeachCleanParamBuilder;

struct AutoCleanParam;
struct AutoCleanParamBuilder;

struct AutoBorderRouteCleanWay;
struct AutoBorderRouteCleanWayBuilder;

struct CoreUnit;
struct CoreUnitBuilder;

struct MotorUnit;
struct MotorUnitBuilder;

struct SensorUnit;
struct SensorUnitBuilder;

struct OtherUnit;
struct OtherUnitBuilder;

struct ParamData;
struct ParamDataBuilder;

struct WalkingMotorParams;
struct WalkingMotorParamsBuilder;

struct LeftAndRightBrushMotorParams;
struct LeftAndRightBrushMotorParamsBuilder;

struct MainBrushMotorParams;
struct MainBrushMotorParamsBuilder;

struct BrushWirePusherParams;
struct BrushWirePusherParamsBuilder;

struct WaterHangingWirePusherParams;
struct WaterHangingWirePusherParamsBuilder;

struct SuctionPumpParams;
struct SuctionPumpParamsBuilder;

struct CleanWaterPumpParams;
struct CleanWaterPumpParamsBuilder;

struct BatteryParams;
struct BatteryParamsBuilder;

struct MachineParamRqst;
struct MachineParamRqstBuilder;

struct MachineParamResp;
struct MachineParamRespBuilder;

struct WorkingModeData;
struct WorkingModeDataBuilder;

struct WorkingHoursData;
struct WorkingHoursDataBuilder;

struct WirePusher;
struct WirePusherBuilder;

struct WaterPumpGear;
struct WaterPumpGearBuilder;

struct Brake;
struct BrakeBuilder;

struct LightBelt;
struct LightBeltBuilder;

struct TestingItem;
struct TestingItemBuilder;

struct EquipmentTestingResp;
struct EquipmentTestingRespBuilder;

struct FaultSettingData;
struct FaultSettingDataBuilder;

struct FaultSettingResp;
struct FaultSettingRespBuilder;

struct ModeSetting;
struct ModeSettingBuilder;

struct RecordData;
struct RecordDataBuilder;

struct RouteInfo;
struct RouteInfoBuilder;

struct HoursData;
struct HoursDataBuilder;

struct WorkLog;
struct WorkLogBuilder;

struct PersonPoint;

struct ElevatorPoint;

struct OrientedPoint;

struct LoginUser;
struct LoginUserBuilder;

struct Public;
struct PublicBuilder;

enum FaultState {
  FaultState_On = 0,
  FaultState_Off = 1,
  FaultState_MIN = FaultState_On,
  FaultState_MAX = FaultState_Off
};

inline const FaultState (&EnumValuesFaultState())[2] {
  static const FaultState values[] = {
    FaultState_On,
    FaultState_Off
  };
  return values;
}

inline const char * const *EnumNamesFaultState() {
  static const char * const names[3] = {
    "On",
    "Off",
    nullptr
  };
  return names;
}

inline const char *EnumNameFaultState(FaultState e) {
  if (flatbuffers::IsOutRange(e, FaultState_On, FaultState_Off)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFaultState()[index];
}

enum CleanMode {
  CleanMode_Economize = 0,
  CleanMode_Strong = 1,
  CleanMode_MIN = CleanMode_Economize,
  CleanMode_MAX = CleanMode_Strong
};

inline const CleanMode (&EnumValuesCleanMode())[2] {
  static const CleanMode values[] = {
    CleanMode_Economize,
    CleanMode_Strong
  };
  return values;
}

inline const char * const *EnumNamesCleanMode() {
  static const char * const names[3] = {
    "Economize",
    "Strong",
    nullptr
  };
  return names;
}

inline const char *EnumNameCleanMode(CleanMode e) {
  if (flatbuffers::IsOutRange(e, CleanMode_Economize, CleanMode_Strong)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCleanMode()[index];
}

enum WorkClass {
  WorkClass_Default = 0,
  WorkClass_Charging = 1,
  WorkClass_Manual = 2,
  WorkClass_Teaching = 4,
  WorkClass_Autonomous = 5,
  WorkClass_MIN = WorkClass_Default,
  WorkClass_MAX = WorkClass_Autonomous
};

inline const WorkClass (&EnumValuesWorkClass())[5] {
  static const WorkClass values[] = {
    WorkClass_Default,
    WorkClass_Charging,
    WorkClass_Manual,
    WorkClass_Teaching,
    WorkClass_Autonomous
  };
  return values;
}

inline const char * const *EnumNamesWorkClass() {
  static const char * const names[7] = {
    "Default",
    "Charging",
    "Manual",
    "",
    "Teaching",
    "Autonomous",
    nullptr
  };
  return names;
}

inline const char *EnumNameWorkClass(WorkClass e) {
  if (flatbuffers::IsOutRange(e, WorkClass_Default, WorkClass_Autonomous)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesWorkClass()[index];
}

enum ManualState {
  ManualState_Start = 0,
  ManualState_Pause = 1,
  ManualState_Continue = 2,
  ManualState_Stop = 3,
  ManualState_MIN = ManualState_Start,
  ManualState_MAX = ManualState_Stop
};

inline const ManualState (&EnumValuesManualState())[4] {
  static const ManualState values[] = {
    ManualState_Start,
    ManualState_Pause,
    ManualState_Continue,
    ManualState_Stop
  };
  return values;
}

inline const char * const *EnumNamesManualState() {
  static const char * const names[5] = {
    "Start",
    "Pause",
    "Continue",
    "Stop",
    nullptr
  };
  return names;
}

inline const char *EnumNameManualState(ManualState e) {
  if (flatbuffers::IsOutRange(e, ManualState_Start, ManualState_Stop)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesManualState()[index];
}

enum IntelligenceMode {
  IntelligenceMode_Teach = 0,
  IntelligenceMode_Auto = 1,
  IntelligenceMode_MIN = IntelligenceMode_Teach,
  IntelligenceMode_MAX = IntelligenceMode_Auto
};

inline const IntelligenceMode (&EnumValuesIntelligenceMode())[2] {
  static const IntelligenceMode values[] = {
    IntelligenceMode_Teach,
    IntelligenceMode_Auto
  };
  return values;
}

inline const char * const *EnumNamesIntelligenceMode() {
  static const char * const names[3] = {
    "Teach",
    "Auto",
    nullptr
  };
  return names;
}

inline const char *EnumNameIntelligenceMode(IntelligenceMode e) {
  if (flatbuffers::IsOutRange(e, IntelligenceMode_Teach, IntelligenceMode_Auto)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesIntelligenceMode()[index];
}

enum PlanMode {
  PlanMode_Path = 0,
  PlanMode_Edge = 1,
  PlanMode_MIN = PlanMode_Path,
  PlanMode_MAX = PlanMode_Edge
};

inline const PlanMode (&EnumValuesPlanMode())[2] {
  static const PlanMode values[] = {
    PlanMode_Path,
    PlanMode_Edge
  };
  return values;
}

inline const char * const *EnumNamesPlanMode() {
  static const char * const names[3] = {
    "Path",
    "Edge",
    nullptr
  };
  return names;
}

inline const char *EnumNamePlanMode(PlanMode e) {
  if (flatbuffers::IsOutRange(e, PlanMode_Path, PlanMode_Edge)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPlanMode()[index];
}

enum CleanState {
  CleanState_Start = 0,
  CleanState_Close = 1,
  CleanState_Pause = 2,
  CleanState_Wake = 3,
  CleanState_Cancel = 4,
  CleanState_MIN = CleanState_Start,
  CleanState_MAX = CleanState_Cancel
};

inline const CleanState (&EnumValuesCleanState())[5] {
  static const CleanState values[] = {
    CleanState_Start,
    CleanState_Close,
    CleanState_Pause,
    CleanState_Wake,
    CleanState_Cancel
  };
  return values;
}

inline const char * const *EnumNamesCleanState() {
  static const char * const names[6] = {
    "Start",
    "Close",
    "Pause",
    "Wake",
    "Cancel",
    nullptr
  };
  return names;
}

inline const char *EnumNameCleanState(CleanState e) {
  if (flatbuffers::IsOutRange(e, CleanState_Start, CleanState_Cancel)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCleanState()[index];
}

enum AutoCleanState {
  AutoCleanState_StartSuccess = 0,
  AutoCleanState_StartFail = 1,
  AutoCleanState_FinishSuccess = 2,
  AutoCleanState_FinishFail = 3,
  AutoCleanState_MIN = AutoCleanState_StartSuccess,
  AutoCleanState_MAX = AutoCleanState_FinishFail
};

inline const AutoCleanState (&EnumValuesAutoCleanState())[4] {
  static const AutoCleanState values[] = {
    AutoCleanState_StartSuccess,
    AutoCleanState_StartFail,
    AutoCleanState_FinishSuccess,
    AutoCleanState_FinishFail
  };
  return values;
}

inline const char * const *EnumNamesAutoCleanState() {
  static const char * const names[5] = {
    "StartSuccess",
    "StartFail",
    "FinishSuccess",
    "FinishFail",
    nullptr
  };
  return names;
}

inline const char *EnumNameAutoCleanState(AutoCleanState e) {
  if (flatbuffers::IsOutRange(e, AutoCleanState_StartSuccess, AutoCleanState_FinishFail)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAutoCleanState()[index];
}

enum CleanWay {
  CleanWay_Default = 0,
  CleanWay_Economize = 1,
  CleanWay_Strong = 2,
  CleanWay_Mopping = 3,
  CleanWay_MIN = CleanWay_Default,
  CleanWay_MAX = CleanWay_Mopping
};

inline const CleanWay (&EnumValuesCleanWay())[4] {
  static const CleanWay values[] = {
    CleanWay_Default,
    CleanWay_Economize,
    CleanWay_Strong,
    CleanWay_Mopping
  };
  return values;
}

inline const char * const *EnumNamesCleanWay() {
  static const char * const names[5] = {
    "Default",
    "Economize",
    "Strong",
    "Mopping",
    nullptr
  };
  return names;
}

inline const char *EnumNameCleanWay(CleanWay e) {
  if (flatbuffers::IsOutRange(e, CleanWay_Default, CleanWay_Mopping)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCleanWay()[index];
}

enum MarkerState {
  MarkerState_Success = 0,
  MarkerState_ImageIsEmpty = 1,
  MarkerState_ImageNotGray = 2,
  MarkerState_TargetNoIdDetected = 3,
  MarkerState_TargetMoreThanOneIdDetected = 4,
  MarkerState_TargetMatchNotUnique = 5,
  MarkerState_TargetOnlyIdDetected = 6,
  MarkerState_TargetIsNotPlane = 7,
  MarkerState_TargetNotWorkspaceTooFar = 8,
  MarkerState_TargetNotWorkspaceTooClose = 9,
  MarkerState_TargetNotWorkspaceOutOfDegreeRange = 10,
  MarkerState_TargetNotWorkspaceOutOfDegreeRangeLeft = 11,
  MarkerState_TargetNotWorkspaceOutOfDegreeRangeRight = 12,
  MarkerState_TargetWorkspaceTilt = 13,
  MarkerState_TargetWorkspaceTiltLeft = 14,
  MarkerState_TargetWorkspaceTiltRight = 15,
  MarkerState_TargetWorkspacePitch = 16,
  MarkerState_TargetWorkspacePitchUp = 17,
  MarkerState_TargetWorkspacePitchDown = 18,
  MarkerState_TargetWorkspaceSideWay = 19,
  MarkerState_TargetWorkspaceSideWayLeft = 20,
  MarkerState_TargetWorkspaceSideWayRight = 21,
  MarkerState_TargetWorkspaceFlip = 22,
  MarkerState_TargetIsDifferentFromCheckCode = 23,
  MarkerState_Unknown = 24,
  MarkerState_MIN = MarkerState_Success,
  MarkerState_MAX = MarkerState_Unknown
};

inline const MarkerState (&EnumValuesMarkerState())[25] {
  static const MarkerState values[] = {
    MarkerState_Success,
    MarkerState_ImageIsEmpty,
    MarkerState_ImageNotGray,
    MarkerState_TargetNoIdDetected,
    MarkerState_TargetMoreThanOneIdDetected,
    MarkerState_TargetMatchNotUnique,
    MarkerState_TargetOnlyIdDetected,
    MarkerState_TargetIsNotPlane,
    MarkerState_TargetNotWorkspaceTooFar,
    MarkerState_TargetNotWorkspaceTooClose,
    MarkerState_TargetNotWorkspaceOutOfDegreeRange,
    MarkerState_TargetNotWorkspaceOutOfDegreeRangeLeft,
    MarkerState_TargetNotWorkspaceOutOfDegreeRangeRight,
    MarkerState_TargetWorkspaceTilt,
    MarkerState_TargetWorkspaceTiltLeft,
    MarkerState_TargetWorkspaceTiltRight,
    MarkerState_TargetWorkspacePitch,
    MarkerState_TargetWorkspacePitchUp,
    MarkerState_TargetWorkspacePitchDown,
    MarkerState_TargetWorkspaceSideWay,
    MarkerState_TargetWorkspaceSideWayLeft,
    MarkerState_TargetWorkspaceSideWayRight,
    MarkerState_TargetWorkspaceFlip,
    MarkerState_TargetIsDifferentFromCheckCode,
    MarkerState_Unknown
  };
  return values;
}

inline const char * const *EnumNamesMarkerState() {
  static const char * const names[26] = {
    "Success",
    "ImageIsEmpty",
    "ImageNotGray",
    "TargetNoIdDetected",
    "TargetMoreThanOneIdDetected",
    "TargetMatchNotUnique",
    "TargetOnlyIdDetected",
    "TargetIsNotPlane",
    "TargetNotWorkspaceTooFar",
    "TargetNotWorkspaceTooClose",
    "TargetNotWorkspaceOutOfDegreeRange",
    "TargetNotWorkspaceOutOfDegreeRangeLeft",
    "TargetNotWorkspaceOutOfDegreeRangeRight",
    "TargetWorkspaceTilt",
    "TargetWorkspaceTiltLeft",
    "TargetWorkspaceTiltRight",
    "TargetWorkspacePitch",
    "TargetWorkspacePitchUp",
    "TargetWorkspacePitchDown",
    "TargetWorkspaceSideWay",
    "TargetWorkspaceSideWayLeft",
    "TargetWorkspaceSideWayRight",
    "TargetWorkspaceFlip",
    "TargetIsDifferentFromCheckCode",
    "Unknown",
    nullptr
  };
  return names;
}

inline const char *EnumNameMarkerState(MarkerState e) {
  if (flatbuffers::IsOutRange(e, MarkerState_Success, MarkerState_Unknown)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMarkerState()[index];
}

enum AutoBorderWay {
  AutoBorderWay_Bow = 0,
  AutoBorderWay_Circle = 1,
  AutoBorderWay_MIN = AutoBorderWay_Bow,
  AutoBorderWay_MAX = AutoBorderWay_Circle
};

inline const AutoBorderWay (&EnumValuesAutoBorderWay())[2] {
  static const AutoBorderWay values[] = {
    AutoBorderWay_Bow,
    AutoBorderWay_Circle
  };
  return values;
}

inline const char * const *EnumNamesAutoBorderWay() {
  static const char * const names[3] = {
    "Bow",
    "Circle",
    nullptr
  };
  return names;
}

inline const char *EnumNameAutoBorderWay(AutoBorderWay e) {
  if (flatbuffers::IsOutRange(e, AutoBorderWay_Bow, AutoBorderWay_Circle)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAutoBorderWay()[index];
}

enum EquipmentUnitType {
  EquipmentUnitType_Core = 0,
  EquipmentUnitType_Motor = 1,
  EquipmentUnitType_Sensor = 2,
  EquipmentUnitType_Other = 3,
  EquipmentUnitType_MIN = EquipmentUnitType_Core,
  EquipmentUnitType_MAX = EquipmentUnitType_Other
};

inline const EquipmentUnitType (&EnumValuesEquipmentUnitType())[4] {
  static const EquipmentUnitType values[] = {
    EquipmentUnitType_Core,
    EquipmentUnitType_Motor,
    EquipmentUnitType_Sensor,
    EquipmentUnitType_Other
  };
  return values;
}

inline const char * const *EnumNamesEquipmentUnitType() {
  static const char * const names[5] = {
    "Core",
    "Motor",
    "Sensor",
    "Other",
    nullptr
  };
  return names;
}

inline const char *EnumNameEquipmentUnitType(EquipmentUnitType e) {
  if (flatbuffers::IsOutRange(e, EquipmentUnitType_Core, EquipmentUnitType_Other)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEquipmentUnitType()[index];
}

enum EquipmentUnitData {
  EquipmentUnitData_NONE = 0,
  EquipmentUnitData_CoreUnit = 1,
  EquipmentUnitData_MotorUnit = 2,
  EquipmentUnitData_SensorUnit = 3,
  EquipmentUnitData_OtherUnit = 4,
  EquipmentUnitData_MIN = EquipmentUnitData_NONE,
  EquipmentUnitData_MAX = EquipmentUnitData_OtherUnit
};

inline const EquipmentUnitData (&EnumValuesEquipmentUnitData())[5] {
  static const EquipmentUnitData values[] = {
    EquipmentUnitData_NONE,
    EquipmentUnitData_CoreUnit,
    EquipmentUnitData_MotorUnit,
    EquipmentUnitData_SensorUnit,
    EquipmentUnitData_OtherUnit
  };
  return values;
}

inline const char * const *EnumNamesEquipmentUnitData() {
  static const char * const names[6] = {
    "NONE",
    "CoreUnit",
    "MotorUnit",
    "SensorUnit",
    "OtherUnit",
    nullptr
  };
  return names;
}

inline const char *EnumNameEquipmentUnitData(EquipmentUnitData e) {
  if (flatbuffers::IsOutRange(e, EquipmentUnitData_NONE, EquipmentUnitData_OtherUnit)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEquipmentUnitData()[index];
}

template<typename T> struct EquipmentUnitDataTraits {
  static const EquipmentUnitData enum_value = EquipmentUnitData_NONE;
};

template<> struct EquipmentUnitDataTraits<swr::CoreUnit> {
  static const EquipmentUnitData enum_value = EquipmentUnitData_CoreUnit;
};

template<> struct EquipmentUnitDataTraits<swr::MotorUnit> {
  static const EquipmentUnitData enum_value = EquipmentUnitData_MotorUnit;
};

template<> struct EquipmentUnitDataTraits<swr::SensorUnit> {
  static const EquipmentUnitData enum_value = EquipmentUnitData_SensorUnit;
};

template<> struct EquipmentUnitDataTraits<swr::OtherUnit> {
  static const EquipmentUnitData enum_value = EquipmentUnitData_OtherUnit;
};

bool VerifyEquipmentUnitData(flatbuffers::Verifier &verifier, const void *obj, EquipmentUnitData type);
bool VerifyEquipmentUnitDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum OperType {
  OperType_Get = 0,
  OperType_Set = 1,
  OperType_MIN = OperType_Get,
  OperType_MAX = OperType_Set
};

inline const OperType (&EnumValuesOperType())[2] {
  static const OperType values[] = {
    OperType_Get,
    OperType_Set
  };
  return values;
}

inline const char * const *EnumNamesOperType() {
  static const char * const names[3] = {
    "Get",
    "Set",
    nullptr
  };
  return names;
}

inline const char *EnumNameOperType(OperType e) {
  if (flatbuffers::IsOutRange(e, OperType_Get, OperType_Set)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOperType()[index];
}

enum MachineParamsModule {
  MachineParamsModule_WalkingMotor = 0,
  MachineParamsModule_LeftAndRightBrushMotor = 1,
  MachineParamsModule_MainBrushMotor = 2,
  MachineParamsModule_BrushWirePusher = 3,
  MachineParamsModule_WaterHangingWirePusher = 4,
  MachineParamsModule_SuctionPump = 5,
  MachineParamsModule_CleanWaterPump = 6,
  MachineParamsModule_Battery = 7,
  MachineParamsModule_MIN = MachineParamsModule_WalkingMotor,
  MachineParamsModule_MAX = MachineParamsModule_Battery
};

inline const MachineParamsModule (&EnumValuesMachineParamsModule())[8] {
  static const MachineParamsModule values[] = {
    MachineParamsModule_WalkingMotor,
    MachineParamsModule_LeftAndRightBrushMotor,
    MachineParamsModule_MainBrushMotor,
    MachineParamsModule_BrushWirePusher,
    MachineParamsModule_WaterHangingWirePusher,
    MachineParamsModule_SuctionPump,
    MachineParamsModule_CleanWaterPump,
    MachineParamsModule_Battery
  };
  return values;
}

inline const char * const *EnumNamesMachineParamsModule() {
  static const char * const names[9] = {
    "WalkingMotor",
    "LeftAndRightBrushMotor",
    "MainBrushMotor",
    "BrushWirePusher",
    "WaterHangingWirePusher",
    "SuctionPump",
    "CleanWaterPump",
    "Battery",
    nullptr
  };
  return names;
}

inline const char *EnumNameMachineParamsModule(MachineParamsModule e) {
  if (flatbuffers::IsOutRange(e, MachineParamsModule_WalkingMotor, MachineParamsModule_Battery)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMachineParamsModule()[index];
}

enum MachineParamData {
  MachineParamData_NONE = 0,
  MachineParamData_WalkingMotorParams = 1,
  MachineParamData_LeftAndRightBrushMotorParams = 2,
  MachineParamData_MainBrushMotorParams = 3,
  MachineParamData_BrushWirePusherParams = 4,
  MachineParamData_WaterHangingWirePusherParams = 5,
  MachineParamData_SuctionPumpParams = 6,
  MachineParamData_CleanWaterPumpParams = 7,
  MachineParamData_BatteryParams = 8,
  MachineParamData_MIN = MachineParamData_NONE,
  MachineParamData_MAX = MachineParamData_BatteryParams
};

inline const MachineParamData (&EnumValuesMachineParamData())[9] {
  static const MachineParamData values[] = {
    MachineParamData_NONE,
    MachineParamData_WalkingMotorParams,
    MachineParamData_LeftAndRightBrushMotorParams,
    MachineParamData_MainBrushMotorParams,
    MachineParamData_BrushWirePusherParams,
    MachineParamData_WaterHangingWirePusherParams,
    MachineParamData_SuctionPumpParams,
    MachineParamData_CleanWaterPumpParams,
    MachineParamData_BatteryParams
  };
  return values;
}

inline const char * const *EnumNamesMachineParamData() {
  static const char * const names[10] = {
    "NONE",
    "WalkingMotorParams",
    "LeftAndRightBrushMotorParams",
    "MainBrushMotorParams",
    "BrushWirePusherParams",
    "WaterHangingWirePusherParams",
    "SuctionPumpParams",
    "CleanWaterPumpParams",
    "BatteryParams",
    nullptr
  };
  return names;
}

inline const char *EnumNameMachineParamData(MachineParamData e) {
  if (flatbuffers::IsOutRange(e, MachineParamData_NONE, MachineParamData_BatteryParams)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMachineParamData()[index];
}

template<typename T> struct MachineParamDataTraits {
  static const MachineParamData enum_value = MachineParamData_NONE;
};

template<> struct MachineParamDataTraits<swr::WalkingMotorParams> {
  static const MachineParamData enum_value = MachineParamData_WalkingMotorParams;
};

template<> struct MachineParamDataTraits<swr::LeftAndRightBrushMotorParams> {
  static const MachineParamData enum_value = MachineParamData_LeftAndRightBrushMotorParams;
};

template<> struct MachineParamDataTraits<swr::MainBrushMotorParams> {
  static const MachineParamData enum_value = MachineParamData_MainBrushMotorParams;
};

template<> struct MachineParamDataTraits<swr::BrushWirePusherParams> {
  static const MachineParamData enum_value = MachineParamData_BrushWirePusherParams;
};

template<> struct MachineParamDataTraits<swr::WaterHangingWirePusherParams> {
  static const MachineParamData enum_value = MachineParamData_WaterHangingWirePusherParams;
};

template<> struct MachineParamDataTraits<swr::SuctionPumpParams> {
  static const MachineParamData enum_value = MachineParamData_SuctionPumpParams;
};

template<> struct MachineParamDataTraits<swr::CleanWaterPumpParams> {
  static const MachineParamData enum_value = MachineParamData_CleanWaterPumpParams;
};

template<> struct MachineParamDataTraits<swr::BatteryParams> {
  static const MachineParamData enum_value = MachineParamData_BatteryParams;
};

bool VerifyMachineParamData(flatbuffers::Verifier &verifier, const void *obj, MachineParamData type);
bool VerifyMachineParamDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum TestingType {
  TestingType_StartTesting = 0,
  TestingType_SetSwitch = 1,
  TestingType_MIN = TestingType_StartTesting,
  TestingType_MAX = TestingType_SetSwitch
};

inline const TestingType (&EnumValuesTestingType())[2] {
  static const TestingType values[] = {
    TestingType_StartTesting,
    TestingType_SetSwitch
  };
  return values;
}

inline const char * const *EnumNamesTestingType() {
  static const char * const names[3] = {
    "StartTesting",
    "SetSwitch",
    nullptr
  };
  return names;
}

inline const char *EnumNameTestingType(TestingType e) {
  if (flatbuffers::IsOutRange(e, TestingType_StartTesting, TestingType_SetSwitch)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTestingType()[index];
}

enum TestingItemType {
  TestingItemType_MainBrushMotor = 0,
  TestingItemType_LeftBrushMotor = 1,
  TestingItemType_RightBrushMotor = 2,
  TestingItemType_SuctionPump = 3,
  TestingItemType_BrushWirePusher = 4,
  TestingItemType_WaterHangingWirePusher = 5,
  TestingItemType_WaterPumpGear = 6,
  TestingItemType_LeftBrakeAssembly = 7,
  TestingItemType_RightBrakeAssembly = 8,
  TestingItemType_Horn = 9,
  TestingItemType_LightBelt = 10,
  TestingItemType_MIN = TestingItemType_MainBrushMotor,
  TestingItemType_MAX = TestingItemType_LightBelt
};

inline const TestingItemType (&EnumValuesTestingItemType())[11] {
  static const TestingItemType values[] = {
    TestingItemType_MainBrushMotor,
    TestingItemType_LeftBrushMotor,
    TestingItemType_RightBrushMotor,
    TestingItemType_SuctionPump,
    TestingItemType_BrushWirePusher,
    TestingItemType_WaterHangingWirePusher,
    TestingItemType_WaterPumpGear,
    TestingItemType_LeftBrakeAssembly,
    TestingItemType_RightBrakeAssembly,
    TestingItemType_Horn,
    TestingItemType_LightBelt
  };
  return values;
}

inline const char * const *EnumNamesTestingItemType() {
  static const char * const names[12] = {
    "MainBrushMotor",
    "LeftBrushMotor",
    "RightBrushMotor",
    "SuctionPump",
    "BrushWirePusher",
    "WaterHangingWirePusher",
    "WaterPumpGear",
    "LeftBrakeAssembly",
    "RightBrakeAssembly",
    "Horn",
    "LightBelt",
    nullptr
  };
  return names;
}

inline const char *EnumNameTestingItemType(TestingItemType e) {
  if (flatbuffers::IsOutRange(e, TestingItemType_MainBrushMotor, TestingItemType_LightBelt)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTestingItemType()[index];
}

enum WirePusherOper {
  WirePusherOper_Up = 0,
  WirePusherOper_Down = 1,
  WirePusherOper_Stop = 2,
  WirePusherOper_MIN = WirePusherOper_Up,
  WirePusherOper_MAX = WirePusherOper_Stop
};

inline const WirePusherOper (&EnumValuesWirePusherOper())[3] {
  static const WirePusherOper values[] = {
    WirePusherOper_Up,
    WirePusherOper_Down,
    WirePusherOper_Stop
  };
  return values;
}

inline const char * const *EnumNamesWirePusherOper() {
  static const char * const names[4] = {
    "Up",
    "Down",
    "Stop",
    nullptr
  };
  return names;
}

inline const char *EnumNameWirePusherOper(WirePusherOper e) {
  if (flatbuffers::IsOutRange(e, WirePusherOper_Up, WirePusherOper_Stop)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesWirePusherOper()[index];
}

enum WaterPumpGearOper {
  WaterPumpGearOper_Off = 0,
  WaterPumpGearOper_Gear1 = 1,
  WaterPumpGearOper_Gear2 = 2,
  WaterPumpGearOper_MIN = WaterPumpGearOper_Off,
  WaterPumpGearOper_MAX = WaterPumpGearOper_Gear2
};

inline const WaterPumpGearOper (&EnumValuesWaterPumpGearOper())[3] {
  static const WaterPumpGearOper values[] = {
    WaterPumpGearOper_Off,
    WaterPumpGearOper_Gear1,
    WaterPumpGearOper_Gear2
  };
  return values;
}

inline const char * const *EnumNamesWaterPumpGearOper() {
  static const char * const names[4] = {
    "Off",
    "Gear1",
    "Gear2",
    nullptr
  };
  return names;
}

inline const char *EnumNameWaterPumpGearOper(WaterPumpGearOper e) {
  if (flatbuffers::IsOutRange(e, WaterPumpGearOper_Off, WaterPumpGearOper_Gear2)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesWaterPumpGearOper()[index];
}

enum BrakeOper {
  BrakeOper_Brake = 0,
  BrakeOper_Release = 1,
  BrakeOper_MIN = BrakeOper_Brake,
  BrakeOper_MAX = BrakeOper_Release
};

inline const BrakeOper (&EnumValuesBrakeOper())[2] {
  static const BrakeOper values[] = {
    BrakeOper_Brake,
    BrakeOper_Release
  };
  return values;
}

inline const char * const *EnumNamesBrakeOper() {
  static const char * const names[3] = {
    "Brake",
    "Release",
    nullptr
  };
  return names;
}

inline const char *EnumNameBrakeOper(BrakeOper e) {
  if (flatbuffers::IsOutRange(e, BrakeOper_Brake, BrakeOper_Release)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBrakeOper()[index];
}

enum LightBeltOper {
  LightBeltOper_Off = 0,
  LightBeltOper_Start = 1,
  LightBeltOper_LeftTurn = 2,
  LightBeltOper_RightTurn = 3,
  LightBeltOper_Fault = 4,
  LightBeltOper_NormalStandby = 5,
  LightBeltOper_MechanicalOperation1 = 6,
  LightBeltOper_MechanicalOperation2 = 7,
  LightBeltOper_AllLightsOff = 8,
  LightBeltOper_QueryMode = 9,
  LightBeltOper_TestMode = 10,
  LightBeltOper_MIN = LightBeltOper_Off,
  LightBeltOper_MAX = LightBeltOper_TestMode
};

inline const LightBeltOper (&EnumValuesLightBeltOper())[11] {
  static const LightBeltOper values[] = {
    LightBeltOper_Off,
    LightBeltOper_Start,
    LightBeltOper_LeftTurn,
    LightBeltOper_RightTurn,
    LightBeltOper_Fault,
    LightBeltOper_NormalStandby,
    LightBeltOper_MechanicalOperation1,
    LightBeltOper_MechanicalOperation2,
    LightBeltOper_AllLightsOff,
    LightBeltOper_QueryMode,
    LightBeltOper_TestMode
  };
  return values;
}

inline const char * const *EnumNamesLightBeltOper() {
  static const char * const names[12] = {
    "Off",
    "Start",
    "LeftTurn",
    "RightTurn",
    "Fault",
    "NormalStandby",
    "MechanicalOperation1",
    "MechanicalOperation2",
    "AllLightsOff",
    "QueryMode",
    "TestMode",
    nullptr
  };
  return names;
}

inline const char *EnumNameLightBeltOper(LightBeltOper e) {
  if (flatbuffers::IsOutRange(e, LightBeltOper_Off, LightBeltOper_TestMode)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLightBeltOper()[index];
}

enum TestingItemData {
  TestingItemData_NONE = 0,
  TestingItemData_Switch = 1,
  TestingItemData_WirePusher = 2,
  TestingItemData_WaterPumpGear = 3,
  TestingItemData_Brake = 4,
  TestingItemData_LightBelt = 5,
  TestingItemData_MIN = TestingItemData_NONE,
  TestingItemData_MAX = TestingItemData_LightBelt
};

inline const TestingItemData (&EnumValuesTestingItemData())[6] {
  static const TestingItemData values[] = {
    TestingItemData_NONE,
    TestingItemData_Switch,
    TestingItemData_WirePusher,
    TestingItemData_WaterPumpGear,
    TestingItemData_Brake,
    TestingItemData_LightBelt
  };
  return values;
}

inline const char * const *EnumNamesTestingItemData() {
  static const char * const names[7] = {
    "NONE",
    "Switch",
    "WirePusher",
    "WaterPumpGear",
    "Brake",
    "LightBelt",
    nullptr
  };
  return names;
}

inline const char *EnumNameTestingItemData(TestingItemData e) {
  if (flatbuffers::IsOutRange(e, TestingItemData_NONE, TestingItemData_LightBelt)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTestingItemData()[index];
}

template<typename T> struct TestingItemDataTraits {
  static const TestingItemData enum_value = TestingItemData_NONE;
};

template<> struct TestingItemDataTraits<swr::Switch> {
  static const TestingItemData enum_value = TestingItemData_Switch;
};

template<> struct TestingItemDataTraits<swr::WirePusher> {
  static const TestingItemData enum_value = TestingItemData_WirePusher;
};

template<> struct TestingItemDataTraits<swr::WaterPumpGear> {
  static const TestingItemData enum_value = TestingItemData_WaterPumpGear;
};

template<> struct TestingItemDataTraits<swr::Brake> {
  static const TestingItemData enum_value = TestingItemData_Brake;
};

template<> struct TestingItemDataTraits<swr::LightBelt> {
  static const TestingItemData enum_value = TestingItemData_LightBelt;
};

bool VerifyTestingItemData(flatbuffers::Verifier &verifier, const void *obj, TestingItemData type);
bool VerifyTestingItemDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum FaultSettingRqst {
  FaultSettingRqst_NONE = 0,
  FaultSettingRqst_Switch = 1,
  FaultSettingRqst_FaultSettingData = 2,
  FaultSettingRqst_MIN = FaultSettingRqst_NONE,
  FaultSettingRqst_MAX = FaultSettingRqst_FaultSettingData
};

inline const FaultSettingRqst (&EnumValuesFaultSettingRqst())[3] {
  static const FaultSettingRqst values[] = {
    FaultSettingRqst_NONE,
    FaultSettingRqst_Switch,
    FaultSettingRqst_FaultSettingData
  };
  return values;
}

inline const char * const *EnumNamesFaultSettingRqst() {
  static const char * const names[4] = {
    "NONE",
    "Switch",
    "FaultSettingData",
    nullptr
  };
  return names;
}

inline const char *EnumNameFaultSettingRqst(FaultSettingRqst e) {
  if (flatbuffers::IsOutRange(e, FaultSettingRqst_NONE, FaultSettingRqst_FaultSettingData)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFaultSettingRqst()[index];
}

template<typename T> struct FaultSettingRqstTraits {
  static const FaultSettingRqst enum_value = FaultSettingRqst_NONE;
};

template<> struct FaultSettingRqstTraits<swr::Switch> {
  static const FaultSettingRqst enum_value = FaultSettingRqst_Switch;
};

template<> struct FaultSettingRqstTraits<swr::FaultSettingData> {
  static const FaultSettingRqst enum_value = FaultSettingRqst_FaultSettingData;
};

bool VerifyFaultSettingRqst(flatbuffers::Verifier &verifier, const void *obj, FaultSettingRqst type);
bool VerifyFaultSettingRqstVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum LoginType {
  LoginType_HmiUser = 0,
  LoginType_HmiUserAdmin = 1,
  LoginType_CustomerManagement = 2,
  LoginType_MIN = LoginType_HmiUser,
  LoginType_MAX = LoginType_CustomerManagement
};

inline const LoginType (&EnumValuesLoginType())[3] {
  static const LoginType values[] = {
    LoginType_HmiUser,
    LoginType_HmiUserAdmin,
    LoginType_CustomerManagement
  };
  return values;
}

inline const char * const *EnumNamesLoginType() {
  static const char * const names[4] = {
    "HmiUser",
    "HmiUserAdmin",
    "CustomerManagement",
    nullptr
  };
  return names;
}

inline const char *EnumNameLoginType(LoginType e) {
  if (flatbuffers::IsOutRange(e, LoginType_HmiUser, LoginType_CustomerManagement)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLoginType()[index];
}

enum UserType {
  UserType_CustomerManagement = 0,
  UserType_HmiUserAdmin = 1,
  UserType_Owner4 = 2,
  UserType_Owner5 = 3,
  UserType_Owner6 = 4,
  UserType_Owner7 = 5,
  UserType_Owner8 = 6,
  UserType_Owner9 = 7,
  UserType_MIN = UserType_CustomerManagement,
  UserType_MAX = UserType_Owner9
};

inline const UserType (&EnumValuesUserType())[8] {
  static const UserType values[] = {
    UserType_CustomerManagement,
    UserType_HmiUserAdmin,
    UserType_Owner4,
    UserType_Owner5,
    UserType_Owner6,
    UserType_Owner7,
    UserType_Owner8,
    UserType_Owner9
  };
  return values;
}

inline const char * const *EnumNamesUserType() {
  static const char * const names[9] = {
    "CustomerManagement",
    "HmiUserAdmin",
    "Owner4",
    "Owner5",
    "Owner6",
    "Owner7",
    "Owner8",
    "Owner9",
    nullptr
  };
  return names;
}

inline const char *EnumNameUserType(UserType e) {
  if (flatbuffers::IsOutRange(e, UserType_CustomerManagement, UserType_Owner9)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUserType()[index];
}

//////////////////// 请求类型 ////////////////////
enum RequestType {
  RequestType_SelfTest = 0,
  RequestType_HMI = 1,
  RequestType_CleanMode = 2,
  RequestType_Manual = 3,
  RequestType_Video = 4,
  RequestType_ScanQR = 5,
  RequestType_TeachClean = 6,
  RequestType_AutoClean = 7,
  RequestType_AboutThisMachine = 8,
  RequestType_OperationRecord = 9,
  RequestType_EquipmentStatus = 10,
  RequestType_SiteRoutes = 11,
  RequestType_DelRoute = 12,
  RequestType_TransSlot = 13,
  RequestType_DownloadRoute = 14,
  RequestType_VerifyPassword = 15,
  RequestType_MachineParams = 16,
  RequestType_EquipmentTesting = 17,
  RequestType_EquipmentTestingItem = 18,
  RequestType_FaultSetting = 19,
  RequestType_WorkingMode = 20,
  RequestType_WorkingHours = 21,
  RequestType_ChangePassword = 22,
  RequestType_SiteCode = 23,
  RequestType_SavingPower = 24,
  RequestType_Standby = 25,
  RequestType_OneButtonSwitch = 26,
  RequestType_PowerDown = 27,
  RequestType_MotionControl = 28,
  RequestType_SetVolume = 29,
  RequestType_GetVolume = 30,
  RequestType_EnableWifi = 31,
  RequestType_FaultCode = 32,
  RequestType_AutoBorderRouteCleanWay = 33,
  RequestType_GoHome = 34,
  RequestType_ResumeClean = 35,
  RequestType_SetBright = 36,
  RequestType_GetBright = 37,
  RequestType_GetVcuData = 38,
  RequestType_SlamOptimize = 39,
  RequestType_TestConsumables = 40,
  RequestType_CloseEquitment = 41,
  RequestType_ExitStandby = 42,
  RequestType_UpdateExceptionConfig = 43,
  RequestType_LockState = 44,
  RequestType_Login = 45,
  RequestType_UpdatePwd = 46,
  RequestType_UserList = 47,
  RequestType_MIN = RequestType_SelfTest,
  RequestType_MAX = RequestType_UserList
};

inline const RequestType (&EnumValuesRequestType())[48] {
  static const RequestType values[] = {
    RequestType_SelfTest,
    RequestType_HMI,
    RequestType_CleanMode,
    RequestType_Manual,
    RequestType_Video,
    RequestType_ScanQR,
    RequestType_TeachClean,
    RequestType_AutoClean,
    RequestType_AboutThisMachine,
    RequestType_OperationRecord,
    RequestType_EquipmentStatus,
    RequestType_SiteRoutes,
    RequestType_DelRoute,
    RequestType_TransSlot,
    RequestType_DownloadRoute,
    RequestType_VerifyPassword,
    RequestType_MachineParams,
    RequestType_EquipmentTesting,
    RequestType_EquipmentTestingItem,
    RequestType_FaultSetting,
    RequestType_WorkingMode,
    RequestType_WorkingHours,
    RequestType_ChangePassword,
    RequestType_SiteCode,
    RequestType_SavingPower,
    RequestType_Standby,
    RequestType_OneButtonSwitch,
    RequestType_PowerDown,
    RequestType_MotionControl,
    RequestType_SetVolume,
    RequestType_GetVolume,
    RequestType_EnableWifi,
    RequestType_FaultCode,
    RequestType_AutoBorderRouteCleanWay,
    RequestType_GoHome,
    RequestType_ResumeClean,
    RequestType_SetBright,
    RequestType_GetBright,
    RequestType_GetVcuData,
    RequestType_SlamOptimize,
    RequestType_TestConsumables,
    RequestType_CloseEquitment,
    RequestType_ExitStandby,
    RequestType_UpdateExceptionConfig,
    RequestType_LockState,
    RequestType_Login,
    RequestType_UpdatePwd,
    RequestType_UserList
  };
  return values;
}

inline const char * const *EnumNamesRequestType() {
  static const char * const names[49] = {
    "SelfTest",
    "HMI",
    "CleanMode",
    "Manual",
    "Video",
    "ScanQR",
    "TeachClean",
    "AutoClean",
    "AboutThisMachine",
    "OperationRecord",
    "EquipmentStatus",
    "SiteRoutes",
    "DelRoute",
    "TransSlot",
    "DownloadRoute",
    "VerifyPassword",
    "MachineParams",
    "EquipmentTesting",
    "EquipmentTestingItem",
    "FaultSetting",
    "WorkingMode",
    "WorkingHours",
    "ChangePassword",
    "SiteCode",
    "SavingPower",
    "Standby",
    "OneButtonSwitch",
    "PowerDown",
    "MotionControl",
    "SetVolume",
    "GetVolume",
    "EnableWifi",
    "FaultCode",
    "AutoBorderRouteCleanWay",
    "GoHome",
    "ResumeClean",
    "SetBright",
    "GetBright",
    "GetVcuData",
    "SlamOptimize",
    "TestConsumables",
    "CloseEquitment",
    "ExitStandby",
    "UpdateExceptionConfig",
    "LockState",
    "Login",
    "UpdatePwd",
    "UserList",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequestType(RequestType e) {
  if (flatbuffers::IsOutRange(e, RequestType_SelfTest, RequestType_UserList)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequestType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) FaultCode FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t code_;
  int8_t state_;
  int8_t padding0__;  int16_t padding1__;

 public:
  FaultCode() {
    memset(static_cast<void *>(this), 0, sizeof(FaultCode));
  }
  FaultCode(uint32_t _code, swr::FaultState _state)
      : code_(flatbuffers::EndianScalar(_code)),
        state_(flatbuffers::EndianScalar(static_cast<int8_t>(_state))),
        padding0__(0),
        padding1__(0) {
    (void)padding0__;    (void)padding1__;
  }
  uint32_t code() const {
    return flatbuffers::EndianScalar(code_);
  }
  swr::FaultState state() const {
    return static_cast<swr::FaultState>(flatbuffers::EndianScalar(state_));
  }
};
FLATBUFFERS_STRUCT_END(FaultCode, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) PersonPoint FLATBUFFERS_FINAL_CLASS {
 private:
  double x_;
  double y_;

 public:
  PersonPoint() {
    memset(static_cast<void *>(this), 0, sizeof(PersonPoint));
  }
  PersonPoint(double _x, double _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  double x() const {
    return flatbuffers::EndianScalar(x_);
  }
  double y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(PersonPoint, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) ElevatorPoint FLATBUFFERS_FINAL_CLASS {
 private:
  double lx_;
  double ly_;
  double rx_;
  double ry_;

 public:
  ElevatorPoint() {
    memset(static_cast<void *>(this), 0, sizeof(ElevatorPoint));
  }
  ElevatorPoint(double _lx, double _ly, double _rx, double _ry)
      : lx_(flatbuffers::EndianScalar(_lx)),
        ly_(flatbuffers::EndianScalar(_ly)),
        rx_(flatbuffers::EndianScalar(_rx)),
        ry_(flatbuffers::EndianScalar(_ry)) {
  }
  double lx() const {
    return flatbuffers::EndianScalar(lx_);
  }
  double ly() const {
    return flatbuffers::EndianScalar(ly_);
  }
  double rx() const {
    return flatbuffers::EndianScalar(rx_);
  }
  double ry() const {
    return flatbuffers::EndianScalar(ry_);
  }
};
FLATBUFFERS_STRUCT_END(ElevatorPoint, 32);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) OrientedPoint FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float a_;

 public:
  OrientedPoint() {
    memset(static_cast<void *>(this), 0, sizeof(OrientedPoint));
  }
  OrientedPoint(float _x, float _y, float _a)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        a_(flatbuffers::EndianScalar(_a)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float a() const {
    return flatbuffers::EndianScalar(a_);
  }
};
FLATBUFFERS_STRUCT_END(OrientedPoint, 12);

struct ErrorCode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ErrorCodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATE = 4,
    VT_TYPE = 6,
    VT_MODULE_ = 8,
    VT_ERROR = 10,
    VT_TIME = 12
  };
  bool state() const {
    return GetField<uint8_t>(VT_STATE, 0) != 0;
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  int32_t module_() const {
    return GetField<int32_t>(VT_MODULE_, 0);
  }
  int64_t error() const {
    return GetField<int64_t>(VT_ERROR, 0);
  }
  int64_t time() const {
    return GetField<int64_t>(VT_TIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STATE) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_MODULE_) &&
           VerifyField<int64_t>(verifier, VT_ERROR) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           verifier.EndTable();
  }
};

struct ErrorCodeBuilder {
  typedef ErrorCode Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state(bool state) {
    fbb_.AddElement<uint8_t>(ErrorCode::VT_STATE, static_cast<uint8_t>(state), 0);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ErrorCode::VT_TYPE, type, 0);
  }
  void add_module_(int32_t module_) {
    fbb_.AddElement<int32_t>(ErrorCode::VT_MODULE_, module_, 0);
  }
  void add_error(int64_t error) {
    fbb_.AddElement<int64_t>(ErrorCode::VT_ERROR, error, 0);
  }
  void add_time(int64_t time) {
    fbb_.AddElement<int64_t>(ErrorCode::VT_TIME, time, 0);
  }
  explicit ErrorCodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ErrorCodeBuilder &operator=(const ErrorCodeBuilder &);
  flatbuffers::Offset<ErrorCode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ErrorCode>(end);
    return o;
  }
};

inline flatbuffers::Offset<ErrorCode> CreateErrorCode(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool state = false,
    int32_t type = 0,
    int32_t module_ = 0,
    int64_t error = 0,
    int64_t time = 0) {
  ErrorCodeBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_error(error);
  builder_.add_module_(module_);
  builder_.add_type(type);
  builder_.add_state(state);
  return builder_.Finish();
}

struct LockFaultCode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LockFaultCodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4,
    VT_STATE = 6,
    VT_BODY_NUM = 8
  };
  uint32_t code() const {
    return GetField<uint32_t>(VT_CODE, 0);
  }
  swr::FaultState state() const {
    return static_cast<swr::FaultState>(GetField<int8_t>(VT_STATE, 0));
  }
  const flatbuffers::String *body_num() const {
    return GetPointer<const flatbuffers::String *>(VT_BODY_NUM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CODE) &&
           VerifyField<int8_t>(verifier, VT_STATE) &&
           VerifyOffset(verifier, VT_BODY_NUM) &&
           verifier.VerifyString(body_num()) &&
           verifier.EndTable();
  }
};

struct LockFaultCodeBuilder {
  typedef LockFaultCode Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(uint32_t code) {
    fbb_.AddElement<uint32_t>(LockFaultCode::VT_CODE, code, 0);
  }
  void add_state(swr::FaultState state) {
    fbb_.AddElement<int8_t>(LockFaultCode::VT_STATE, static_cast<int8_t>(state), 0);
  }
  void add_body_num(flatbuffers::Offset<flatbuffers::String> body_num) {
    fbb_.AddOffset(LockFaultCode::VT_BODY_NUM, body_num);
  }
  explicit LockFaultCodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LockFaultCodeBuilder &operator=(const LockFaultCodeBuilder &);
  flatbuffers::Offset<LockFaultCode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LockFaultCode>(end);
    return o;
  }
};

inline flatbuffers::Offset<LockFaultCode> CreateLockFaultCode(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t code = 0,
    swr::FaultState state = swr::FaultState_On,
    flatbuffers::Offset<flatbuffers::String> body_num = 0) {
  LockFaultCodeBuilder builder_(_fbb);
  builder_.add_body_num(body_num);
  builder_.add_code(code);
  builder_.add_state(state);
  return builder_.Finish();
}

inline flatbuffers::Offset<LockFaultCode> CreateLockFaultCodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t code = 0,
    swr::FaultState state = swr::FaultState_On,
    const char *body_num = nullptr) {
  auto body_num__ = body_num ? _fbb.CreateString(body_num) : 0;
  return swr::CreateLockFaultCode(
      _fbb,
      code,
      state,
      body_num__);
}

struct Switch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SwitchBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ON = 4
  };
  bool on() const {
    return GetField<uint8_t>(VT_ON, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ON) &&
           verifier.EndTable();
  }
};

struct SwitchBuilder {
  typedef Switch Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_on(bool on) {
    fbb_.AddElement<uint8_t>(Switch::VT_ON, static_cast<uint8_t>(on), 0);
  }
  explicit SwitchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SwitchBuilder &operator=(const SwitchBuilder &);
  flatbuffers::Offset<Switch> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Switch>(end);
    return o;
  }
};

inline flatbuffers::Offset<Switch> CreateSwitch(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool on = false) {
  SwitchBuilder builder_(_fbb);
  builder_.add_on(on);
  return builder_.Finish();
}

struct RouteIdent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RouteIdentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SITE_CODE = 4,
    VT_HLC_CODE = 6,
    VT_SLOT_CODE = 8,
    VT_ROUTE_ID = 10
  };
  const flatbuffers::String *site_code() const {
    return GetPointer<const flatbuffers::String *>(VT_SITE_CODE);
  }
  const flatbuffers::String *hlc_code() const {
    return GetPointer<const flatbuffers::String *>(VT_HLC_CODE);
  }
  uint8_t slot_code() const {
    return GetField<uint8_t>(VT_SLOT_CODE, 0);
  }
  const flatbuffers::String *route_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ROUTE_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SITE_CODE) &&
           verifier.VerifyString(site_code()) &&
           VerifyOffset(verifier, VT_HLC_CODE) &&
           verifier.VerifyString(hlc_code()) &&
           VerifyField<uint8_t>(verifier, VT_SLOT_CODE) &&
           VerifyOffset(verifier, VT_ROUTE_ID) &&
           verifier.VerifyString(route_id()) &&
           verifier.EndTable();
  }
};

struct RouteIdentBuilder {
  typedef RouteIdent Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_site_code(flatbuffers::Offset<flatbuffers::String> site_code) {
    fbb_.AddOffset(RouteIdent::VT_SITE_CODE, site_code);
  }
  void add_hlc_code(flatbuffers::Offset<flatbuffers::String> hlc_code) {
    fbb_.AddOffset(RouteIdent::VT_HLC_CODE, hlc_code);
  }
  void add_slot_code(uint8_t slot_code) {
    fbb_.AddElement<uint8_t>(RouteIdent::VT_SLOT_CODE, slot_code, 0);
  }
  void add_route_id(flatbuffers::Offset<flatbuffers::String> route_id) {
    fbb_.AddOffset(RouteIdent::VT_ROUTE_ID, route_id);
  }
  explicit RouteIdentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RouteIdentBuilder &operator=(const RouteIdentBuilder &);
  flatbuffers::Offset<RouteIdent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RouteIdent>(end);
    return o;
  }
};

inline flatbuffers::Offset<RouteIdent> CreateRouteIdent(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> site_code = 0,
    flatbuffers::Offset<flatbuffers::String> hlc_code = 0,
    uint8_t slot_code = 0,
    flatbuffers::Offset<flatbuffers::String> route_id = 0) {
  RouteIdentBuilder builder_(_fbb);
  builder_.add_route_id(route_id);
  builder_.add_hlc_code(hlc_code);
  builder_.add_site_code(site_code);
  builder_.add_slot_code(slot_code);
  return builder_.Finish();
}

inline flatbuffers::Offset<RouteIdent> CreateRouteIdentDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *site_code = nullptr,
    const char *hlc_code = nullptr,
    uint8_t slot_code = 0,
    const char *route_id = nullptr) {
  auto site_code__ = site_code ? _fbb.CreateString(site_code) : 0;
  auto hlc_code__ = hlc_code ? _fbb.CreateString(hlc_code) : 0;
  auto route_id__ = route_id ? _fbb.CreateString(route_id) : 0;
  return swr::CreateRouteIdent(
      _fbb,
      site_code__,
      hlc_code__,
      slot_code,
      route_id__);
}

struct TeachCleanParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TeachCleanParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4,
    VT_SITE_CODE = 6,
    VT_HLC_CODE = 8,
    VT_SLOT_CODE = 10
  };
  swr::PlanMode mode() const {
    return static_cast<swr::PlanMode>(GetField<int8_t>(VT_MODE, 0));
  }
  const flatbuffers::String *site_code() const {
    return GetPointer<const flatbuffers::String *>(VT_SITE_CODE);
  }
  const flatbuffers::String *hlc_code() const {
    return GetPointer<const flatbuffers::String *>(VT_HLC_CODE);
  }
  uint8_t slot_code() const {
    return GetField<uint8_t>(VT_SLOT_CODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MODE) &&
           VerifyOffset(verifier, VT_SITE_CODE) &&
           verifier.VerifyString(site_code()) &&
           VerifyOffset(verifier, VT_HLC_CODE) &&
           verifier.VerifyString(hlc_code()) &&
           VerifyField<uint8_t>(verifier, VT_SLOT_CODE) &&
           verifier.EndTable();
  }
};

struct TeachCleanParamBuilder {
  typedef TeachCleanParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(swr::PlanMode mode) {
    fbb_.AddElement<int8_t>(TeachCleanParam::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  void add_site_code(flatbuffers::Offset<flatbuffers::String> site_code) {
    fbb_.AddOffset(TeachCleanParam::VT_SITE_CODE, site_code);
  }
  void add_hlc_code(flatbuffers::Offset<flatbuffers::String> hlc_code) {
    fbb_.AddOffset(TeachCleanParam::VT_HLC_CODE, hlc_code);
  }
  void add_slot_code(uint8_t slot_code) {
    fbb_.AddElement<uint8_t>(TeachCleanParam::VT_SLOT_CODE, slot_code, 0);
  }
  explicit TeachCleanParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TeachCleanParamBuilder &operator=(const TeachCleanParamBuilder &);
  flatbuffers::Offset<TeachCleanParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TeachCleanParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<TeachCleanParam> CreateTeachCleanParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    swr::PlanMode mode = swr::PlanMode_Path,
    flatbuffers::Offset<flatbuffers::String> site_code = 0,
    flatbuffers::Offset<flatbuffers::String> hlc_code = 0,
    uint8_t slot_code = 0) {
  TeachCleanParamBuilder builder_(_fbb);
  builder_.add_hlc_code(hlc_code);
  builder_.add_site_code(site_code);
  builder_.add_slot_code(slot_code);
  builder_.add_mode(mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<TeachCleanParam> CreateTeachCleanParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    swr::PlanMode mode = swr::PlanMode_Path,
    const char *site_code = nullptr,
    const char *hlc_code = nullptr,
    uint8_t slot_code = 0) {
  auto site_code__ = site_code ? _fbb.CreateString(site_code) : 0;
  auto hlc_code__ = hlc_code ? _fbb.CreateString(hlc_code) : 0;
  return swr::CreateTeachCleanParam(
      _fbb,
      mode,
      site_code__,
      hlc_code__,
      slot_code);
}

struct AutoCleanParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AutoCleanParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLEAN_WAY = 4,
    VT_CLEAN_NUM = 6,
    VT_ROUTE_LIST = 8,
    VT_RUN_CODE = 10,
    VT_RUN_PATH = 12
  };
  swr::CleanWay clean_way() const {
    return static_cast<swr::CleanWay>(GetField<int8_t>(VT_CLEAN_WAY, 0));
  }
  int32_t clean_num() const {
    return GetField<int32_t>(VT_CLEAN_NUM, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<swr::RouteIdent>> *route_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<swr::RouteIdent>> *>(VT_ROUTE_LIST);
  }
  const flatbuffers::String *run_code() const {
    return GetPointer<const flatbuffers::String *>(VT_RUN_CODE);
  }
  const flatbuffers::String *run_path() const {
    return GetPointer<const flatbuffers::String *>(VT_RUN_PATH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_CLEAN_WAY) &&
           VerifyField<int32_t>(verifier, VT_CLEAN_NUM) &&
           VerifyOffset(verifier, VT_ROUTE_LIST) &&
           verifier.VerifyVector(route_list()) &&
           verifier.VerifyVectorOfTables(route_list()) &&
           VerifyOffset(verifier, VT_RUN_CODE) &&
           verifier.VerifyString(run_code()) &&
           VerifyOffset(verifier, VT_RUN_PATH) &&
           verifier.VerifyString(run_path()) &&
           verifier.EndTable();
  }
};

struct AutoCleanParamBuilder {
  typedef AutoCleanParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_clean_way(swr::CleanWay clean_way) {
    fbb_.AddElement<int8_t>(AutoCleanParam::VT_CLEAN_WAY, static_cast<int8_t>(clean_way), 0);
  }
  void add_clean_num(int32_t clean_num) {
    fbb_.AddElement<int32_t>(AutoCleanParam::VT_CLEAN_NUM, clean_num, 0);
  }
  void add_route_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<swr::RouteIdent>>> route_list) {
    fbb_.AddOffset(AutoCleanParam::VT_ROUTE_LIST, route_list);
  }
  void add_run_code(flatbuffers::Offset<flatbuffers::String> run_code) {
    fbb_.AddOffset(AutoCleanParam::VT_RUN_CODE, run_code);
  }
  void add_run_path(flatbuffers::Offset<flatbuffers::String> run_path) {
    fbb_.AddOffset(AutoCleanParam::VT_RUN_PATH, run_path);
  }
  explicit AutoCleanParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AutoCleanParamBuilder &operator=(const AutoCleanParamBuilder &);
  flatbuffers::Offset<AutoCleanParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AutoCleanParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<AutoCleanParam> CreateAutoCleanParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    swr::CleanWay clean_way = swr::CleanWay_Default,
    int32_t clean_num = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<swr::RouteIdent>>> route_list = 0,
    flatbuffers::Offset<flatbuffers::String> run_code = 0,
    flatbuffers::Offset<flatbuffers::String> run_path = 0) {
  AutoCleanParamBuilder builder_(_fbb);
  builder_.add_run_path(run_path);
  builder_.add_run_code(run_code);
  builder_.add_route_list(route_list);
  builder_.add_clean_num(clean_num);
  builder_.add_clean_way(clean_way);
  return builder_.Finish();
}

inline flatbuffers::Offset<AutoCleanParam> CreateAutoCleanParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    swr::CleanWay clean_way = swr::CleanWay_Default,
    int32_t clean_num = 0,
    const std::vector<flatbuffers::Offset<swr::RouteIdent>> *route_list = nullptr,
    const char *run_code = nullptr,
    const char *run_path = nullptr) {
  auto route_list__ = route_list ? _fbb.CreateVector<flatbuffers::Offset<swr::RouteIdent>>(*route_list) : 0;
  auto run_code__ = run_code ? _fbb.CreateString(run_code) : 0;
  auto run_path__ = run_path ? _fbb.CreateString(run_path) : 0;
  return swr::CreateAutoCleanParam(
      _fbb,
      clean_way,
      clean_num,
      route_list__,
      run_code__,
      run_path__);
}

struct AutoBorderRouteCleanWay FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AutoBorderRouteCleanWayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WAY = 4,
    VT_ROUTE = 6
  };
  swr::AutoBorderWay way() const {
    return static_cast<swr::AutoBorderWay>(GetField<int8_t>(VT_WAY, 0));
  }
  const swr::RouteIdent *route() const {
    return GetPointer<const swr::RouteIdent *>(VT_ROUTE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_WAY) &&
           VerifyOffset(verifier, VT_ROUTE) &&
           verifier.VerifyTable(route()) &&
           verifier.EndTable();
  }
};

struct AutoBorderRouteCleanWayBuilder {
  typedef AutoBorderRouteCleanWay Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_way(swr::AutoBorderWay way) {
    fbb_.AddElement<int8_t>(AutoBorderRouteCleanWay::VT_WAY, static_cast<int8_t>(way), 0);
  }
  void add_route(flatbuffers::Offset<swr::RouteIdent> route) {
    fbb_.AddOffset(AutoBorderRouteCleanWay::VT_ROUTE, route);
  }
  explicit AutoBorderRouteCleanWayBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AutoBorderRouteCleanWayBuilder &operator=(const AutoBorderRouteCleanWayBuilder &);
  flatbuffers::Offset<AutoBorderRouteCleanWay> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AutoBorderRouteCleanWay>(end);
    return o;
  }
};

inline flatbuffers::Offset<AutoBorderRouteCleanWay> CreateAutoBorderRouteCleanWay(
    flatbuffers::FlatBufferBuilder &_fbb,
    swr::AutoBorderWay way = swr::AutoBorderWay_Bow,
    flatbuffers::Offset<swr::RouteIdent> route = 0) {
  AutoBorderRouteCleanWayBuilder builder_(_fbb);
  builder_.add_route(route);
  builder_.add_way(way);
  return builder_.Finish();
}

struct CoreUnit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CoreUnitBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BATTERY_VOLTAGE = 4,
    VT_CELL_TEMPERATURE = 6,
    VT_BMS_TEMPERATURE = 8,
    VT_MCU_TEMPERATURE = 10,
    VT_NCU_CPU_TEMPERATURE = 12,
    VT_NCU_CPU_FREQUENCY = 14,
    VT_NCU_MEMORY_REMAINING1 = 16,
    VT_NCU_MEMORY_REMAINING2 = 18,
    VT_REMAINING_CAPACITY_OF_NCU1 = 20,
    VT_REMAINING_CAPACITY_OF_NCU2 = 22,
    VT_NCU_COOLING_FAN_SPEED = 24,
    VT_WHEEL_MILEAGE_COUNT = 26
  };
  float battery_voltage() const {
    return GetField<float>(VT_BATTERY_VOLTAGE, 0.0f);
  }
  float cell_temperature() const {
    return GetField<float>(VT_CELL_TEMPERATURE, 0.0f);
  }
  float bms_temperature() const {
    return GetField<float>(VT_BMS_TEMPERATURE, 0.0f);
  }
  float mcu_temperature() const {
    return GetField<float>(VT_MCU_TEMPERATURE, 0.0f);
  }
  float ncu_cpu_temperature() const {
    return GetField<float>(VT_NCU_CPU_TEMPERATURE, 0.0f);
  }
  float ncu_cpu_frequency() const {
    return GetField<float>(VT_NCU_CPU_FREQUENCY, 0.0f);
  }
  float ncu_memory_remaining1() const {
    return GetField<float>(VT_NCU_MEMORY_REMAINING1, 0.0f);
  }
  float ncu_memory_remaining2() const {
    return GetField<float>(VT_NCU_MEMORY_REMAINING2, 0.0f);
  }
  float remaining_capacity_of_ncu1() const {
    return GetField<float>(VT_REMAINING_CAPACITY_OF_NCU1, 0.0f);
  }
  float remaining_capacity_of_ncu2() const {
    return GetField<float>(VT_REMAINING_CAPACITY_OF_NCU2, 0.0f);
  }
  int32_t ncu_cooling_fan_speed() const {
    return GetField<int32_t>(VT_NCU_COOLING_FAN_SPEED, 0);
  }
  int32_t wheel_mileage_count() const {
    return GetField<int32_t>(VT_WHEEL_MILEAGE_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BATTERY_VOLTAGE) &&
           VerifyField<float>(verifier, VT_CELL_TEMPERATURE) &&
           VerifyField<float>(verifier, VT_BMS_TEMPERATURE) &&
           VerifyField<float>(verifier, VT_MCU_TEMPERATURE) &&
           VerifyField<float>(verifier, VT_NCU_CPU_TEMPERATURE) &&
           VerifyField<float>(verifier, VT_NCU_CPU_FREQUENCY) &&
           VerifyField<float>(verifier, VT_NCU_MEMORY_REMAINING1) &&
           VerifyField<float>(verifier, VT_NCU_MEMORY_REMAINING2) &&
           VerifyField<float>(verifier, VT_REMAINING_CAPACITY_OF_NCU1) &&
           VerifyField<float>(verifier, VT_REMAINING_CAPACITY_OF_NCU2) &&
           VerifyField<int32_t>(verifier, VT_NCU_COOLING_FAN_SPEED) &&
           VerifyField<int32_t>(verifier, VT_WHEEL_MILEAGE_COUNT) &&
           verifier.EndTable();
  }
};

struct CoreUnitBuilder {
  typedef CoreUnit Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_battery_voltage(float battery_voltage) {
    fbb_.AddElement<float>(CoreUnit::VT_BATTERY_VOLTAGE, battery_voltage, 0.0f);
  }
  void add_cell_temperature(float cell_temperature) {
    fbb_.AddElement<float>(CoreUnit::VT_CELL_TEMPERATURE, cell_temperature, 0.0f);
  }
  void add_bms_temperature(float bms_temperature) {
    fbb_.AddElement<float>(CoreUnit::VT_BMS_TEMPERATURE, bms_temperature, 0.0f);
  }
  void add_mcu_temperature(float mcu_temperature) {
    fbb_.AddElement<float>(CoreUnit::VT_MCU_TEMPERATURE, mcu_temperature, 0.0f);
  }
  void add_ncu_cpu_temperature(float ncu_cpu_temperature) {
    fbb_.AddElement<float>(CoreUnit::VT_NCU_CPU_TEMPERATURE, ncu_cpu_temperature, 0.0f);
  }
  void add_ncu_cpu_frequency(float ncu_cpu_frequency) {
    fbb_.AddElement<float>(CoreUnit::VT_NCU_CPU_FREQUENCY, ncu_cpu_frequency, 0.0f);
  }
  void add_ncu_memory_remaining1(float ncu_memory_remaining1) {
    fbb_.AddElement<float>(CoreUnit::VT_NCU_MEMORY_REMAINING1, ncu_memory_remaining1, 0.0f);
  }
  void add_ncu_memory_remaining2(float ncu_memory_remaining2) {
    fbb_.AddElement<float>(CoreUnit::VT_NCU_MEMORY_REMAINING2, ncu_memory_remaining2, 0.0f);
  }
  void add_remaining_capacity_of_ncu1(float remaining_capacity_of_ncu1) {
    fbb_.AddElement<float>(CoreUnit::VT_REMAINING_CAPACITY_OF_NCU1, remaining_capacity_of_ncu1, 0.0f);
  }
  void add_remaining_capacity_of_ncu2(float remaining_capacity_of_ncu2) {
    fbb_.AddElement<float>(CoreUnit::VT_REMAINING_CAPACITY_OF_NCU2, remaining_capacity_of_ncu2, 0.0f);
  }
  void add_ncu_cooling_fan_speed(int32_t ncu_cooling_fan_speed) {
    fbb_.AddElement<int32_t>(CoreUnit::VT_NCU_COOLING_FAN_SPEED, ncu_cooling_fan_speed, 0);
  }
  void add_wheel_mileage_count(int32_t wheel_mileage_count) {
    fbb_.AddElement<int32_t>(CoreUnit::VT_WHEEL_MILEAGE_COUNT, wheel_mileage_count, 0);
  }
  explicit CoreUnitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CoreUnitBuilder &operator=(const CoreUnitBuilder &);
  flatbuffers::Offset<CoreUnit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CoreUnit>(end);
    return o;
  }
};

inline flatbuffers::Offset<CoreUnit> CreateCoreUnit(
    flatbuffers::FlatBufferBuilder &_fbb,
    float battery_voltage = 0.0f,
    float cell_temperature = 0.0f,
    float bms_temperature = 0.0f,
    float mcu_temperature = 0.0f,
    float ncu_cpu_temperature = 0.0f,
    float ncu_cpu_frequency = 0.0f,
    float ncu_memory_remaining1 = 0.0f,
    float ncu_memory_remaining2 = 0.0f,
    float remaining_capacity_of_ncu1 = 0.0f,
    float remaining_capacity_of_ncu2 = 0.0f,
    int32_t ncu_cooling_fan_speed = 0,
    int32_t wheel_mileage_count = 0) {
  CoreUnitBuilder builder_(_fbb);
  builder_.add_wheel_mileage_count(wheel_mileage_count);
  builder_.add_ncu_cooling_fan_speed(ncu_cooling_fan_speed);
  builder_.add_remaining_capacity_of_ncu2(remaining_capacity_of_ncu2);
  builder_.add_remaining_capacity_of_ncu1(remaining_capacity_of_ncu1);
  builder_.add_ncu_memory_remaining2(ncu_memory_remaining2);
  builder_.add_ncu_memory_remaining1(ncu_memory_remaining1);
  builder_.add_ncu_cpu_frequency(ncu_cpu_frequency);
  builder_.add_ncu_cpu_temperature(ncu_cpu_temperature);
  builder_.add_mcu_temperature(mcu_temperature);
  builder_.add_bms_temperature(bms_temperature);
  builder_.add_cell_temperature(cell_temperature);
  builder_.add_battery_voltage(battery_voltage);
  return builder_.Finish();
}

struct MotorUnit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MotorUnitBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEFT_TRAVEL_MOTOR_CURRENT = 4,
    VT_RIGHT_TRAVEL_MOTOR_CURRENT = 6,
    VT_LEFT_BRUSH_MOTOR_CURRENT = 8,
    VT_MOS_TUBE_TEMPERATURE_OF_LEFT_BRUSH_MOTOR = 10,
    VT_RIGHT_BRUSH_MOTOR_CURRENT = 12,
    VT_RIGHT_BRUSH_MOTOR_MOS_TUBE_TEMPERATURE = 14,
    VT_MAIN_BRUSH_MOTOR_CURRENT = 16,
    VT_BRUSH_WIRE_PUSHER_CURRENT = 18,
    VT_WIPER_WIRE_PUSHER_CURRENT = 20,
    VT_SUCTION_PUMP_CURRENT = 22,
    VT_SUCTION_PUMP_TEMPERATURE = 24,
    VT_CLEAN_WATER_PUMP = 26
  };
  float left_travel_motor_current() const {
    return GetField<float>(VT_LEFT_TRAVEL_MOTOR_CURRENT, 0.0f);
  }
  float right_travel_motor_current() const {
    return GetField<float>(VT_RIGHT_TRAVEL_MOTOR_CURRENT, 0.0f);
  }
  float left_brush_motor_current() const {
    return GetField<float>(VT_LEFT_BRUSH_MOTOR_CURRENT, 0.0f);
  }
  float mos_tube_temperature_of_left_brush_motor() const {
    return GetField<float>(VT_MOS_TUBE_TEMPERATURE_OF_LEFT_BRUSH_MOTOR, 0.0f);
  }
  float right_brush_motor_current() const {
    return GetField<float>(VT_RIGHT_BRUSH_MOTOR_CURRENT, 0.0f);
  }
  float right_brush_motor_mos_tube_temperature() const {
    return GetField<float>(VT_RIGHT_BRUSH_MOTOR_MOS_TUBE_TEMPERATURE, 0.0f);
  }
  float main_brush_motor_current() const {
    return GetField<float>(VT_MAIN_BRUSH_MOTOR_CURRENT, 0.0f);
  }
  float brush_wire_pusher_current() const {
    return GetField<float>(VT_BRUSH_WIRE_PUSHER_CURRENT, 0.0f);
  }
  float wiper_wire_pusher_current() const {
    return GetField<float>(VT_WIPER_WIRE_PUSHER_CURRENT, 0.0f);
  }
  float suction_pump_current() const {
    return GetField<float>(VT_SUCTION_PUMP_CURRENT, 0.0f);
  }
  float suction_pump_temperature() const {
    return GetField<float>(VT_SUCTION_PUMP_TEMPERATURE, 0.0f);
  }
  bool clean_water_pump() const {
    return GetField<uint8_t>(VT_CLEAN_WATER_PUMP, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_LEFT_TRAVEL_MOTOR_CURRENT) &&
           VerifyField<float>(verifier, VT_RIGHT_TRAVEL_MOTOR_CURRENT) &&
           VerifyField<float>(verifier, VT_LEFT_BRUSH_MOTOR_CURRENT) &&
           VerifyField<float>(verifier, VT_MOS_TUBE_TEMPERATURE_OF_LEFT_BRUSH_MOTOR) &&
           VerifyField<float>(verifier, VT_RIGHT_BRUSH_MOTOR_CURRENT) &&
           VerifyField<float>(verifier, VT_RIGHT_BRUSH_MOTOR_MOS_TUBE_TEMPERATURE) &&
           VerifyField<float>(verifier, VT_MAIN_BRUSH_MOTOR_CURRENT) &&
           VerifyField<float>(verifier, VT_BRUSH_WIRE_PUSHER_CURRENT) &&
           VerifyField<float>(verifier, VT_WIPER_WIRE_PUSHER_CURRENT) &&
           VerifyField<float>(verifier, VT_SUCTION_PUMP_CURRENT) &&
           VerifyField<float>(verifier, VT_SUCTION_PUMP_TEMPERATURE) &&
           VerifyField<uint8_t>(verifier, VT_CLEAN_WATER_PUMP) &&
           verifier.EndTable();
  }
};

struct MotorUnitBuilder {
  typedef MotorUnit Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_left_travel_motor_current(float left_travel_motor_current) {
    fbb_.AddElement<float>(MotorUnit::VT_LEFT_TRAVEL_MOTOR_CURRENT, left_travel_motor_current, 0.0f);
  }
  void add_right_travel_motor_current(float right_travel_motor_current) {
    fbb_.AddElement<float>(MotorUnit::VT_RIGHT_TRAVEL_MOTOR_CURRENT, right_travel_motor_current, 0.0f);
  }
  void add_left_brush_motor_current(float left_brush_motor_current) {
    fbb_.AddElement<float>(MotorUnit::VT_LEFT_BRUSH_MOTOR_CURRENT, left_brush_motor_current, 0.0f);
  }
  void add_mos_tube_temperature_of_left_brush_motor(float mos_tube_temperature_of_left_brush_motor) {
    fbb_.AddElement<float>(MotorUnit::VT_MOS_TUBE_TEMPERATURE_OF_LEFT_BRUSH_MOTOR, mos_tube_temperature_of_left_brush_motor, 0.0f);
  }
  void add_right_brush_motor_current(float right_brush_motor_current) {
    fbb_.AddElement<float>(MotorUnit::VT_RIGHT_BRUSH_MOTOR_CURRENT, right_brush_motor_current, 0.0f);
  }
  void add_right_brush_motor_mos_tube_temperature(float right_brush_motor_mos_tube_temperature) {
    fbb_.AddElement<float>(MotorUnit::VT_RIGHT_BRUSH_MOTOR_MOS_TUBE_TEMPERATURE, right_brush_motor_mos_tube_temperature, 0.0f);
  }
  void add_main_brush_motor_current(float main_brush_motor_current) {
    fbb_.AddElement<float>(MotorUnit::VT_MAIN_BRUSH_MOTOR_CURRENT, main_brush_motor_current, 0.0f);
  }
  void add_brush_wire_pusher_current(float brush_wire_pusher_current) {
    fbb_.AddElement<float>(MotorUnit::VT_BRUSH_WIRE_PUSHER_CURRENT, brush_wire_pusher_current, 0.0f);
  }
  void add_wiper_wire_pusher_current(float wiper_wire_pusher_current) {
    fbb_.AddElement<float>(MotorUnit::VT_WIPER_WIRE_PUSHER_CURRENT, wiper_wire_pusher_current, 0.0f);
  }
  void add_suction_pump_current(float suction_pump_current) {
    fbb_.AddElement<float>(MotorUnit::VT_SUCTION_PUMP_CURRENT, suction_pump_current, 0.0f);
  }
  void add_suction_pump_temperature(float suction_pump_temperature) {
    fbb_.AddElement<float>(MotorUnit::VT_SUCTION_PUMP_TEMPERATURE, suction_pump_temperature, 0.0f);
  }
  void add_clean_water_pump(bool clean_water_pump) {
    fbb_.AddElement<uint8_t>(MotorUnit::VT_CLEAN_WATER_PUMP, static_cast<uint8_t>(clean_water_pump), 0);
  }
  explicit MotorUnitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MotorUnitBuilder &operator=(const MotorUnitBuilder &);
  flatbuffers::Offset<MotorUnit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MotorUnit>(end);
    return o;
  }
};

inline flatbuffers::Offset<MotorUnit> CreateMotorUnit(
    flatbuffers::FlatBufferBuilder &_fbb,
    float left_travel_motor_current = 0.0f,
    float right_travel_motor_current = 0.0f,
    float left_brush_motor_current = 0.0f,
    float mos_tube_temperature_of_left_brush_motor = 0.0f,
    float right_brush_motor_current = 0.0f,
    float right_brush_motor_mos_tube_temperature = 0.0f,
    float main_brush_motor_current = 0.0f,
    float brush_wire_pusher_current = 0.0f,
    float wiper_wire_pusher_current = 0.0f,
    float suction_pump_current = 0.0f,
    float suction_pump_temperature = 0.0f,
    bool clean_water_pump = false) {
  MotorUnitBuilder builder_(_fbb);
  builder_.add_suction_pump_temperature(suction_pump_temperature);
  builder_.add_suction_pump_current(suction_pump_current);
  builder_.add_wiper_wire_pusher_current(wiper_wire_pusher_current);
  builder_.add_brush_wire_pusher_current(brush_wire_pusher_current);
  builder_.add_main_brush_motor_current(main_brush_motor_current);
  builder_.add_right_brush_motor_mos_tube_temperature(right_brush_motor_mos_tube_temperature);
  builder_.add_right_brush_motor_current(right_brush_motor_current);
  builder_.add_mos_tube_temperature_of_left_brush_motor(mos_tube_temperature_of_left_brush_motor);
  builder_.add_left_brush_motor_current(left_brush_motor_current);
  builder_.add_right_travel_motor_current(right_travel_motor_current);
  builder_.add_left_travel_motor_current(left_travel_motor_current);
  builder_.add_clean_water_pump(clean_water_pump);
  return builder_.Finish();
}

struct SensorUnit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SensorUnitBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_START_STOP_SWITCH = 4,
    VT_BINOCULAR_COMPLEMENTARY_BRIGHTNESS = 6,
    VT_BINOCULAR_SPECKLE_BRIGHTNESS = 8,
    VT_IMU = 10,
    VT_LIDAR = 12,
    VT_TOF = 14,
    VT_TOF_BRIGHTNESS = 16,
    VT_CLIFF_FRONT_LEFT = 18,
    VT_CLIFF_FRONT_RIGHT = 20,
    VT_CLIFF_LEFT = 22,
    VT_CLIFF_RIGHT = 24,
    VT_COLLISION_FRONT_LEFT = 26,
    VT_COLLISION_FRONT_RIGHT = 28,
    VT_THE_LEFT_WHEEL_IS_IN_THE_AIR = 30,
    VT_RIGHT_WHEEL_SUSPENDED = 32,
    VT_ULTRASOUND_FRONT_LEFT = 34,
    VT_ULTRASONIC_FRONT_LEFT_DETECTION_RANGE = 36,
    VT_ULTRASOUND_FRONT_RIGHT = 38,
    VT_ULTRASONIC_FRONT_RIGHT_DETECTION_RANGE = 40,
    VT_ULTRASOUND_LEFT = 42,
    VT_ULTRASONIC_LEFT_DETECTION_RANGE = 44,
    VT_ULTRASOUND_RIGHT = 46,
    VT_ULTRASONIC_RIGHT_DETECTION_RANGE = 48,
    VT_ULTRASOUND_REAR = 50,
    VT_ULTRASONIC_DETECTION_RANGE = 52,
    VT_ULTRASOUND_FRONT_MIDDLE = 54,
    VT_ULTRASONIC_DETECTION_FRONT_MIDDLE = 56
  };
  bool start_stop_switch() const {
    return GetField<uint8_t>(VT_START_STOP_SWITCH, 0) != 0;
  }
  float binocular_complementary_brightness() const {
    return GetField<float>(VT_BINOCULAR_COMPLEMENTARY_BRIGHTNESS, 0.0f);
  }
  float binocular_speckle_brightness() const {
    return GetField<float>(VT_BINOCULAR_SPECKLE_BRIGHTNESS, 0.0f);
  }
  bool imu() const {
    return GetField<uint8_t>(VT_IMU, 0) != 0;
  }
  bool lidar() const {
    return GetField<uint8_t>(VT_LIDAR, 0) != 0;
  }
  bool tof() const {
    return GetField<uint8_t>(VT_TOF, 0) != 0;
  }
  float tof_brightness() const {
    return GetField<float>(VT_TOF_BRIGHTNESS, 0.0f);
  }
  bool cliff_front_left() const {
    return GetField<uint8_t>(VT_CLIFF_FRONT_LEFT, 0) != 0;
  }
  bool cliff_front_right() const {
    return GetField<uint8_t>(VT_CLIFF_FRONT_RIGHT, 0) != 0;
  }
  bool cliff_left() const {
    return GetField<uint8_t>(VT_CLIFF_LEFT, 0) != 0;
  }
  bool cliff_right() const {
    return GetField<uint8_t>(VT_CLIFF_RIGHT, 0) != 0;
  }
  bool collision_front_left() const {
    return GetField<uint8_t>(VT_COLLISION_FRONT_LEFT, 0) != 0;
  }
  bool collision_front_right() const {
    return GetField<uint8_t>(VT_COLLISION_FRONT_RIGHT, 0) != 0;
  }
  bool the_left_wheel_is_in_the_air() const {
    return GetField<uint8_t>(VT_THE_LEFT_WHEEL_IS_IN_THE_AIR, 0) != 0;
  }
  bool right_wheel_suspended() const {
    return GetField<uint8_t>(VT_RIGHT_WHEEL_SUSPENDED, 0) != 0;
  }
  bool ultrasound_front_left() const {
    return GetField<uint8_t>(VT_ULTRASOUND_FRONT_LEFT, 0) != 0;
  }
  float ultrasonic_front_left_detection_range() const {
    return GetField<float>(VT_ULTRASONIC_FRONT_LEFT_DETECTION_RANGE, 0.0f);
  }
  bool ultrasound_front_right() const {
    return GetField<uint8_t>(VT_ULTRASOUND_FRONT_RIGHT, 0) != 0;
  }
  float ultrasonic_front_right_detection_range() const {
    return GetField<float>(VT_ULTRASONIC_FRONT_RIGHT_DETECTION_RANGE, 0.0f);
  }
  bool ultrasound_left() const {
    return GetField<uint8_t>(VT_ULTRASOUND_LEFT, 0) != 0;
  }
  float ultrasonic_left_detection_range() const {
    return GetField<float>(VT_ULTRASONIC_LEFT_DETECTION_RANGE, 0.0f);
  }
  bool ultrasound_right() const {
    return GetField<uint8_t>(VT_ULTRASOUND_RIGHT, 0) != 0;
  }
  float ultrasonic_right_detection_range() const {
    return GetField<float>(VT_ULTRASONIC_RIGHT_DETECTION_RANGE, 0.0f);
  }
  bool ultrasound_rear() const {
    return GetField<uint8_t>(VT_ULTRASOUND_REAR, 0) != 0;
  }
  float ultrasonic_detection_range() const {
    return GetField<float>(VT_ULTRASONIC_DETECTION_RANGE, 0.0f);
  }
  bool ultrasound_front_middle() const {
    return GetField<uint8_t>(VT_ULTRASOUND_FRONT_MIDDLE, 0) != 0;
  }
  float ultrasonic_detection_front_middle() const {
    return GetField<float>(VT_ULTRASONIC_DETECTION_FRONT_MIDDLE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_START_STOP_SWITCH) &&
           VerifyField<float>(verifier, VT_BINOCULAR_COMPLEMENTARY_BRIGHTNESS) &&
           VerifyField<float>(verifier, VT_BINOCULAR_SPECKLE_BRIGHTNESS) &&
           VerifyField<uint8_t>(verifier, VT_IMU) &&
           VerifyField<uint8_t>(verifier, VT_LIDAR) &&
           VerifyField<uint8_t>(verifier, VT_TOF) &&
           VerifyField<float>(verifier, VT_TOF_BRIGHTNESS) &&
           VerifyField<uint8_t>(verifier, VT_CLIFF_FRONT_LEFT) &&
           VerifyField<uint8_t>(verifier, VT_CLIFF_FRONT_RIGHT) &&
           VerifyField<uint8_t>(verifier, VT_CLIFF_LEFT) &&
           VerifyField<uint8_t>(verifier, VT_CLIFF_RIGHT) &&
           VerifyField<uint8_t>(verifier, VT_COLLISION_FRONT_LEFT) &&
           VerifyField<uint8_t>(verifier, VT_COLLISION_FRONT_RIGHT) &&
           VerifyField<uint8_t>(verifier, VT_THE_LEFT_WHEEL_IS_IN_THE_AIR) &&
           VerifyField<uint8_t>(verifier, VT_RIGHT_WHEEL_SUSPENDED) &&
           VerifyField<uint8_t>(verifier, VT_ULTRASOUND_FRONT_LEFT) &&
           VerifyField<float>(verifier, VT_ULTRASONIC_FRONT_LEFT_DETECTION_RANGE) &&
           VerifyField<uint8_t>(verifier, VT_ULTRASOUND_FRONT_RIGHT) &&
           VerifyField<float>(verifier, VT_ULTRASONIC_FRONT_RIGHT_DETECTION_RANGE) &&
           VerifyField<uint8_t>(verifier, VT_ULTRASOUND_LEFT) &&
           VerifyField<float>(verifier, VT_ULTRASONIC_LEFT_DETECTION_RANGE) &&
           VerifyField<uint8_t>(verifier, VT_ULTRASOUND_RIGHT) &&
           VerifyField<float>(verifier, VT_ULTRASONIC_RIGHT_DETECTION_RANGE) &&
           VerifyField<uint8_t>(verifier, VT_ULTRASOUND_REAR) &&
           VerifyField<float>(verifier, VT_ULTRASONIC_DETECTION_RANGE) &&
           VerifyField<uint8_t>(verifier, VT_ULTRASOUND_FRONT_MIDDLE) &&
           VerifyField<float>(verifier, VT_ULTRASONIC_DETECTION_FRONT_MIDDLE) &&
           verifier.EndTable();
  }
};

struct SensorUnitBuilder {
  typedef SensorUnit Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_start_stop_switch(bool start_stop_switch) {
    fbb_.AddElement<uint8_t>(SensorUnit::VT_START_STOP_SWITCH, static_cast<uint8_t>(start_stop_switch), 0);
  }
  void add_binocular_complementary_brightness(float binocular_complementary_brightness) {
    fbb_.AddElement<float>(SensorUnit::VT_BINOCULAR_COMPLEMENTARY_BRIGHTNESS, binocular_complementary_brightness, 0.0f);
  }
  void add_binocular_speckle_brightness(float binocular_speckle_brightness) {
    fbb_.AddElement<float>(SensorUnit::VT_BINOCULAR_SPECKLE_BRIGHTNESS, binocular_speckle_brightness, 0.0f);
  }
  void add_imu(bool imu) {
    fbb_.AddElement<uint8_t>(SensorUnit::VT_IMU, static_cast<uint8_t>(imu), 0);
  }
  void add_lidar(bool lidar) {
    fbb_.AddElement<uint8_t>(SensorUnit::VT_LIDAR, static_cast<uint8_t>(lidar), 0);
  }
  void add_tof(bool tof) {
    fbb_.AddElement<uint8_t>(SensorUnit::VT_TOF, static_cast<uint8_t>(tof), 0);
  }
  void add_tof_brightness(float tof_brightness) {
    fbb_.AddElement<float>(SensorUnit::VT_TOF_BRIGHTNESS, tof_brightness, 0.0f);
  }
  void add_cliff_front_left(bool cliff_front_left) {
    fbb_.AddElement<uint8_t>(SensorUnit::VT_CLIFF_FRONT_LEFT, static_cast<uint8_t>(cliff_front_left), 0);
  }
  void add_cliff_front_right(bool cliff_front_right) {
    fbb_.AddElement<uint8_t>(SensorUnit::VT_CLIFF_FRONT_RIGHT, static_cast<uint8_t>(cliff_front_right), 0);
  }
  void add_cliff_left(bool cliff_left) {
    fbb_.AddElement<uint8_t>(SensorUnit::VT_CLIFF_LEFT, static_cast<uint8_t>(cliff_left), 0);
  }
  void add_cliff_right(bool cliff_right) {
    fbb_.AddElement<uint8_t>(SensorUnit::VT_CLIFF_RIGHT, static_cast<uint8_t>(cliff_right), 0);
  }
  void add_collision_front_left(bool collision_front_left) {
    fbb_.AddElement<uint8_t>(SensorUnit::VT_COLLISION_FRONT_LEFT, static_cast<uint8_t>(collision_front_left), 0);
  }
  void add_collision_front_right(bool collision_front_right) {
    fbb_.AddElement<uint8_t>(SensorUnit::VT_COLLISION_FRONT_RIGHT, static_cast<uint8_t>(collision_front_right), 0);
  }
  void add_the_left_wheel_is_in_the_air(bool the_left_wheel_is_in_the_air) {
    fbb_.AddElement<uint8_t>(SensorUnit::VT_THE_LEFT_WHEEL_IS_IN_THE_AIR, static_cast<uint8_t>(the_left_wheel_is_in_the_air), 0);
  }
  void add_right_wheel_suspended(bool right_wheel_suspended) {
    fbb_.AddElement<uint8_t>(SensorUnit::VT_RIGHT_WHEEL_SUSPENDED, static_cast<uint8_t>(right_wheel_suspended), 0);
  }
  void add_ultrasound_front_left(bool ultrasound_front_left) {
    fbb_.AddElement<uint8_t>(SensorUnit::VT_ULTRASOUND_FRONT_LEFT, static_cast<uint8_t>(ultrasound_front_left), 0);
  }
  void add_ultrasonic_front_left_detection_range(float ultrasonic_front_left_detection_range) {
    fbb_.AddElement<float>(SensorUnit::VT_ULTRASONIC_FRONT_LEFT_DETECTION_RANGE, ultrasonic_front_left_detection_range, 0.0f);
  }
  void add_ultrasound_front_right(bool ultrasound_front_right) {
    fbb_.AddElement<uint8_t>(SensorUnit::VT_ULTRASOUND_FRONT_RIGHT, static_cast<uint8_t>(ultrasound_front_right), 0);
  }
  void add_ultrasonic_front_right_detection_range(float ultrasonic_front_right_detection_range) {
    fbb_.AddElement<float>(SensorUnit::VT_ULTRASONIC_FRONT_RIGHT_DETECTION_RANGE, ultrasonic_front_right_detection_range, 0.0f);
  }
  void add_ultrasound_left(bool ultrasound_left) {
    fbb_.AddElement<uint8_t>(SensorUnit::VT_ULTRASOUND_LEFT, static_cast<uint8_t>(ultrasound_left), 0);
  }
  void add_ultrasonic_left_detection_range(float ultrasonic_left_detection_range) {
    fbb_.AddElement<float>(SensorUnit::VT_ULTRASONIC_LEFT_DETECTION_RANGE, ultrasonic_left_detection_range, 0.0f);
  }
  void add_ultrasound_right(bool ultrasound_right) {
    fbb_.AddElement<uint8_t>(SensorUnit::VT_ULTRASOUND_RIGHT, static_cast<uint8_t>(ultrasound_right), 0);
  }
  void add_ultrasonic_right_detection_range(float ultrasonic_right_detection_range) {
    fbb_.AddElement<float>(SensorUnit::VT_ULTRASONIC_RIGHT_DETECTION_RANGE, ultrasonic_right_detection_range, 0.0f);
  }
  void add_ultrasound_rear(bool ultrasound_rear) {
    fbb_.AddElement<uint8_t>(SensorUnit::VT_ULTRASOUND_REAR, static_cast<uint8_t>(ultrasound_rear), 0);
  }
  void add_ultrasonic_detection_range(float ultrasonic_detection_range) {
    fbb_.AddElement<float>(SensorUnit::VT_ULTRASONIC_DETECTION_RANGE, ultrasonic_detection_range, 0.0f);
  }
  void add_ultrasound_front_middle(bool ultrasound_front_middle) {
    fbb_.AddElement<uint8_t>(SensorUnit::VT_ULTRASOUND_FRONT_MIDDLE, static_cast<uint8_t>(ultrasound_front_middle), 0);
  }
  void add_ultrasonic_detection_front_middle(float ultrasonic_detection_front_middle) {
    fbb_.AddElement<float>(SensorUnit::VT_ULTRASONIC_DETECTION_FRONT_MIDDLE, ultrasonic_detection_front_middle, 0.0f);
  }
  explicit SensorUnitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SensorUnitBuilder &operator=(const SensorUnitBuilder &);
  flatbuffers::Offset<SensorUnit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SensorUnit>(end);
    return o;
  }
};

inline flatbuffers::Offset<SensorUnit> CreateSensorUnit(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool start_stop_switch = false,
    float binocular_complementary_brightness = 0.0f,
    float binocular_speckle_brightness = 0.0f,
    bool imu = false,
    bool lidar = false,
    bool tof = false,
    float tof_brightness = 0.0f,
    bool cliff_front_left = false,
    bool cliff_front_right = false,
    bool cliff_left = false,
    bool cliff_right = false,
    bool collision_front_left = false,
    bool collision_front_right = false,
    bool the_left_wheel_is_in_the_air = false,
    bool right_wheel_suspended = false,
    bool ultrasound_front_left = false,
    float ultrasonic_front_left_detection_range = 0.0f,
    bool ultrasound_front_right = false,
    float ultrasonic_front_right_detection_range = 0.0f,
    bool ultrasound_left = false,
    float ultrasonic_left_detection_range = 0.0f,
    bool ultrasound_right = false,
    float ultrasonic_right_detection_range = 0.0f,
    bool ultrasound_rear = false,
    float ultrasonic_detection_range = 0.0f,
    bool ultrasound_front_middle = false,
    float ultrasonic_detection_front_middle = 0.0f) {
  SensorUnitBuilder builder_(_fbb);
  builder_.add_ultrasonic_detection_front_middle(ultrasonic_detection_front_middle);
  builder_.add_ultrasonic_detection_range(ultrasonic_detection_range);
  builder_.add_ultrasonic_right_detection_range(ultrasonic_right_detection_range);
  builder_.add_ultrasonic_left_detection_range(ultrasonic_left_detection_range);
  builder_.add_ultrasonic_front_right_detection_range(ultrasonic_front_right_detection_range);
  builder_.add_ultrasonic_front_left_detection_range(ultrasonic_front_left_detection_range);
  builder_.add_tof_brightness(tof_brightness);
  builder_.add_binocular_speckle_brightness(binocular_speckle_brightness);
  builder_.add_binocular_complementary_brightness(binocular_complementary_brightness);
  builder_.add_ultrasound_front_middle(ultrasound_front_middle);
  builder_.add_ultrasound_rear(ultrasound_rear);
  builder_.add_ultrasound_right(ultrasound_right);
  builder_.add_ultrasound_left(ultrasound_left);
  builder_.add_ultrasound_front_right(ultrasound_front_right);
  builder_.add_ultrasound_front_left(ultrasound_front_left);
  builder_.add_right_wheel_suspended(right_wheel_suspended);
  builder_.add_the_left_wheel_is_in_the_air(the_left_wheel_is_in_the_air);
  builder_.add_collision_front_right(collision_front_right);
  builder_.add_collision_front_left(collision_front_left);
  builder_.add_cliff_right(cliff_right);
  builder_.add_cliff_left(cliff_left);
  builder_.add_cliff_front_right(cliff_front_right);
  builder_.add_cliff_front_left(cliff_front_left);
  builder_.add_tof(tof);
  builder_.add_lidar(lidar);
  builder_.add_imu(imu);
  builder_.add_start_stop_switch(start_stop_switch);
  return builder_.Finish();
}

struct OtherUnit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OtherUnitBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEFT_BRAKE_ASSEMBLY = 4,
    VT_RIGHT_BRAKE_ASSEMBLY = 6,
    VT_HORN = 8,
    VT_EMERGENCY_STOP_BUTTON = 10,
    VT_START_STOP_SWITCH = 12,
    VT_WATER_LEVEL_SWITCH = 14,
    VT_SEWAGE_SWITCH = 16
  };
  bool left_brake_assembly() const {
    return GetField<uint8_t>(VT_LEFT_BRAKE_ASSEMBLY, 0) != 0;
  }
  bool right_brake_assembly() const {
    return GetField<uint8_t>(VT_RIGHT_BRAKE_ASSEMBLY, 0) != 0;
  }
  bool horn() const {
    return GetField<uint8_t>(VT_HORN, 0) != 0;
  }
  bool emergency_stop_button() const {
    return GetField<uint8_t>(VT_EMERGENCY_STOP_BUTTON, 0) != 0;
  }
  bool start_stop_switch() const {
    return GetField<uint8_t>(VT_START_STOP_SWITCH, 0) != 0;
  }
  bool water_level_switch() const {
    return GetField<uint8_t>(VT_WATER_LEVEL_SWITCH, 0) != 0;
  }
  bool sewage_switch() const {
    return GetField<uint8_t>(VT_SEWAGE_SWITCH, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_LEFT_BRAKE_ASSEMBLY) &&
           VerifyField<uint8_t>(verifier, VT_RIGHT_BRAKE_ASSEMBLY) &&
           VerifyField<uint8_t>(verifier, VT_HORN) &&
           VerifyField<uint8_t>(verifier, VT_EMERGENCY_STOP_BUTTON) &&
           VerifyField<uint8_t>(verifier, VT_START_STOP_SWITCH) &&
           VerifyField<uint8_t>(verifier, VT_WATER_LEVEL_SWITCH) &&
           VerifyField<uint8_t>(verifier, VT_SEWAGE_SWITCH) &&
           verifier.EndTable();
  }
};

struct OtherUnitBuilder {
  typedef OtherUnit Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_left_brake_assembly(bool left_brake_assembly) {
    fbb_.AddElement<uint8_t>(OtherUnit::VT_LEFT_BRAKE_ASSEMBLY, static_cast<uint8_t>(left_brake_assembly), 0);
  }
  void add_right_brake_assembly(bool right_brake_assembly) {
    fbb_.AddElement<uint8_t>(OtherUnit::VT_RIGHT_BRAKE_ASSEMBLY, static_cast<uint8_t>(right_brake_assembly), 0);
  }
  void add_horn(bool horn) {
    fbb_.AddElement<uint8_t>(OtherUnit::VT_HORN, static_cast<uint8_t>(horn), 0);
  }
  void add_emergency_stop_button(bool emergency_stop_button) {
    fbb_.AddElement<uint8_t>(OtherUnit::VT_EMERGENCY_STOP_BUTTON, static_cast<uint8_t>(emergency_stop_button), 0);
  }
  void add_start_stop_switch(bool start_stop_switch) {
    fbb_.AddElement<uint8_t>(OtherUnit::VT_START_STOP_SWITCH, static_cast<uint8_t>(start_stop_switch), 0);
  }
  void add_water_level_switch(bool water_level_switch) {
    fbb_.AddElement<uint8_t>(OtherUnit::VT_WATER_LEVEL_SWITCH, static_cast<uint8_t>(water_level_switch), 0);
  }
  void add_sewage_switch(bool sewage_switch) {
    fbb_.AddElement<uint8_t>(OtherUnit::VT_SEWAGE_SWITCH, static_cast<uint8_t>(sewage_switch), 0);
  }
  explicit OtherUnitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OtherUnitBuilder &operator=(const OtherUnitBuilder &);
  flatbuffers::Offset<OtherUnit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OtherUnit>(end);
    return o;
  }
};

inline flatbuffers::Offset<OtherUnit> CreateOtherUnit(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool left_brake_assembly = false,
    bool right_brake_assembly = false,
    bool horn = false,
    bool emergency_stop_button = false,
    bool start_stop_switch = false,
    bool water_level_switch = false,
    bool sewage_switch = false) {
  OtherUnitBuilder builder_(_fbb);
  builder_.add_sewage_switch(sewage_switch);
  builder_.add_water_level_switch(water_level_switch);
  builder_.add_start_stop_switch(start_stop_switch);
  builder_.add_emergency_stop_button(emergency_stop_button);
  builder_.add_horn(horn);
  builder_.add_right_brake_assembly(right_brake_assembly);
  builder_.add_left_brake_assembly(left_brake_assembly);
  return builder_.Finish();
}

struct ParamData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ParamDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDR = 4,
    VT_VALUE = 6
  };
  int16_t addr() const {
    return GetField<int16_t>(VT_ADDR, 0);
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_ADDR) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct ParamDataBuilder {
  typedef ParamData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_addr(int16_t addr) {
    fbb_.AddElement<int16_t>(ParamData::VT_ADDR, addr, 0);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(ParamData::VT_VALUE, value, 0.0f);
  }
  explicit ParamDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ParamDataBuilder &operator=(const ParamDataBuilder &);
  flatbuffers::Offset<ParamData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ParamData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ParamData> CreateParamData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t addr = 0,
    float value = 0.0f) {
  ParamDataBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_addr(addr);
  return builder_.Finish();
}

struct WalkingMotorParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WalkingMotorParamsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATED_CURRENT = 4,
    VT_OVERLOAD_CURRENT = 6,
    VT_OVERLOAD_TIME = 8,
    VT_MAXIMUM_SPEED = 10,
    VT_FORWARD_SPEED = 12,
    VT_REVERSE_SPEED = 14
  };
  float rated_current() const {
    return GetField<float>(VT_RATED_CURRENT, 0.0f);
  }
  float overload_current() const {
    return GetField<float>(VT_OVERLOAD_CURRENT, 0.0f);
  }
  float overload_time() const {
    return GetField<float>(VT_OVERLOAD_TIME, 0.0f);
  }
  float maximum_speed() const {
    return GetField<float>(VT_MAXIMUM_SPEED, 0.0f);
  }
  float forward_speed() const {
    return GetField<float>(VT_FORWARD_SPEED, 0.0f);
  }
  float reverse_speed() const {
    return GetField<float>(VT_REVERSE_SPEED, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_RATED_CURRENT) &&
           VerifyField<float>(verifier, VT_OVERLOAD_CURRENT) &&
           VerifyField<float>(verifier, VT_OVERLOAD_TIME) &&
           VerifyField<float>(verifier, VT_MAXIMUM_SPEED) &&
           VerifyField<float>(verifier, VT_FORWARD_SPEED) &&
           VerifyField<float>(verifier, VT_REVERSE_SPEED) &&
           verifier.EndTable();
  }
};

struct WalkingMotorParamsBuilder {
  typedef WalkingMotorParams Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rated_current(float rated_current) {
    fbb_.AddElement<float>(WalkingMotorParams::VT_RATED_CURRENT, rated_current, 0.0f);
  }
  void add_overload_current(float overload_current) {
    fbb_.AddElement<float>(WalkingMotorParams::VT_OVERLOAD_CURRENT, overload_current, 0.0f);
  }
  void add_overload_time(float overload_time) {
    fbb_.AddElement<float>(WalkingMotorParams::VT_OVERLOAD_TIME, overload_time, 0.0f);
  }
  void add_maximum_speed(float maximum_speed) {
    fbb_.AddElement<float>(WalkingMotorParams::VT_MAXIMUM_SPEED, maximum_speed, 0.0f);
  }
  void add_forward_speed(float forward_speed) {
    fbb_.AddElement<float>(WalkingMotorParams::VT_FORWARD_SPEED, forward_speed, 0.0f);
  }
  void add_reverse_speed(float reverse_speed) {
    fbb_.AddElement<float>(WalkingMotorParams::VT_REVERSE_SPEED, reverse_speed, 0.0f);
  }
  explicit WalkingMotorParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WalkingMotorParamsBuilder &operator=(const WalkingMotorParamsBuilder &);
  flatbuffers::Offset<WalkingMotorParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WalkingMotorParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<WalkingMotorParams> CreateWalkingMotorParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    float rated_current = 0.0f,
    float overload_current = 0.0f,
    float overload_time = 0.0f,
    float maximum_speed = 0.0f,
    float forward_speed = 0.0f,
    float reverse_speed = 0.0f) {
  WalkingMotorParamsBuilder builder_(_fbb);
  builder_.add_reverse_speed(reverse_speed);
  builder_.add_forward_speed(forward_speed);
  builder_.add_maximum_speed(maximum_speed);
  builder_.add_overload_time(overload_time);
  builder_.add_overload_current(overload_current);
  builder_.add_rated_current(rated_current);
  return builder_.Finish();
}

struct LeftAndRightBrushMotorParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LeftAndRightBrushMotorParamsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATED_CURRENT = 4,
    VT_OVERLOAD_CURRENT = 6,
    VT_OVERLOAD_TIME = 8
  };
  float rated_current() const {
    return GetField<float>(VT_RATED_CURRENT, 0.0f);
  }
  float overload_current() const {
    return GetField<float>(VT_OVERLOAD_CURRENT, 0.0f);
  }
  float overload_time() const {
    return GetField<float>(VT_OVERLOAD_TIME, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_RATED_CURRENT) &&
           VerifyField<float>(verifier, VT_OVERLOAD_CURRENT) &&
           VerifyField<float>(verifier, VT_OVERLOAD_TIME) &&
           verifier.EndTable();
  }
};

struct LeftAndRightBrushMotorParamsBuilder {
  typedef LeftAndRightBrushMotorParams Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rated_current(float rated_current) {
    fbb_.AddElement<float>(LeftAndRightBrushMotorParams::VT_RATED_CURRENT, rated_current, 0.0f);
  }
  void add_overload_current(float overload_current) {
    fbb_.AddElement<float>(LeftAndRightBrushMotorParams::VT_OVERLOAD_CURRENT, overload_current, 0.0f);
  }
  void add_overload_time(float overload_time) {
    fbb_.AddElement<float>(LeftAndRightBrushMotorParams::VT_OVERLOAD_TIME, overload_time, 0.0f);
  }
  explicit LeftAndRightBrushMotorParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LeftAndRightBrushMotorParamsBuilder &operator=(const LeftAndRightBrushMotorParamsBuilder &);
  flatbuffers::Offset<LeftAndRightBrushMotorParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LeftAndRightBrushMotorParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<LeftAndRightBrushMotorParams> CreateLeftAndRightBrushMotorParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    float rated_current = 0.0f,
    float overload_current = 0.0f,
    float overload_time = 0.0f) {
  LeftAndRightBrushMotorParamsBuilder builder_(_fbb);
  builder_.add_overload_time(overload_time);
  builder_.add_overload_current(overload_current);
  builder_.add_rated_current(rated_current);
  return builder_.Finish();
}

struct MainBrushMotorParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MainBrushMotorParamsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATED_CURRENT = 4,
    VT_OVERLOAD_CURRENT = 6,
    VT_OVERLOAD_TIME = 8,
    VT_PRESSURE_CURRENT_L = 10,
    VT_PRESSURE_CURRENT_M = 12,
    VT_PRESSURE_CURRENT_H = 14
  };
  float rated_current() const {
    return GetField<float>(VT_RATED_CURRENT, 0.0f);
  }
  float overload_current() const {
    return GetField<float>(VT_OVERLOAD_CURRENT, 0.0f);
  }
  float overload_time() const {
    return GetField<float>(VT_OVERLOAD_TIME, 0.0f);
  }
  float pressure_current_l() const {
    return GetField<float>(VT_PRESSURE_CURRENT_L, 0.0f);
  }
  float pressure_current_m() const {
    return GetField<float>(VT_PRESSURE_CURRENT_M, 0.0f);
  }
  float pressure_current_h() const {
    return GetField<float>(VT_PRESSURE_CURRENT_H, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_RATED_CURRENT) &&
           VerifyField<float>(verifier, VT_OVERLOAD_CURRENT) &&
           VerifyField<float>(verifier, VT_OVERLOAD_TIME) &&
           VerifyField<float>(verifier, VT_PRESSURE_CURRENT_L) &&
           VerifyField<float>(verifier, VT_PRESSURE_CURRENT_M) &&
           VerifyField<float>(verifier, VT_PRESSURE_CURRENT_H) &&
           verifier.EndTable();
  }
};

struct MainBrushMotorParamsBuilder {
  typedef MainBrushMotorParams Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rated_current(float rated_current) {
    fbb_.AddElement<float>(MainBrushMotorParams::VT_RATED_CURRENT, rated_current, 0.0f);
  }
  void add_overload_current(float overload_current) {
    fbb_.AddElement<float>(MainBrushMotorParams::VT_OVERLOAD_CURRENT, overload_current, 0.0f);
  }
  void add_overload_time(float overload_time) {
    fbb_.AddElement<float>(MainBrushMotorParams::VT_OVERLOAD_TIME, overload_time, 0.0f);
  }
  void add_pressure_current_l(float pressure_current_l) {
    fbb_.AddElement<float>(MainBrushMotorParams::VT_PRESSURE_CURRENT_L, pressure_current_l, 0.0f);
  }
  void add_pressure_current_m(float pressure_current_m) {
    fbb_.AddElement<float>(MainBrushMotorParams::VT_PRESSURE_CURRENT_M, pressure_current_m, 0.0f);
  }
  void add_pressure_current_h(float pressure_current_h) {
    fbb_.AddElement<float>(MainBrushMotorParams::VT_PRESSURE_CURRENT_H, pressure_current_h, 0.0f);
  }
  explicit MainBrushMotorParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MainBrushMotorParamsBuilder &operator=(const MainBrushMotorParamsBuilder &);
  flatbuffers::Offset<MainBrushMotorParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MainBrushMotorParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<MainBrushMotorParams> CreateMainBrushMotorParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    float rated_current = 0.0f,
    float overload_current = 0.0f,
    float overload_time = 0.0f,
    float pressure_current_l = 0.0f,
    float pressure_current_m = 0.0f,
    float pressure_current_h = 0.0f) {
  MainBrushMotorParamsBuilder builder_(_fbb);
  builder_.add_pressure_current_h(pressure_current_h);
  builder_.add_pressure_current_m(pressure_current_m);
  builder_.add_pressure_current_l(pressure_current_l);
  builder_.add_overload_time(overload_time);
  builder_.add_overload_current(overload_current);
  builder_.add_rated_current(rated_current);
  return builder_.Finish();
}

struct BrushWirePusherParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BrushWirePusherParamsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATED_CURRENT = 4,
    VT_OVERLOAD_CURRENT = 6,
    VT_OVERLOAD_TIME = 8,
    VT_UPLINK_TIMING_TIME = 10,
    VT_DOWNLINK_TIMING_TIME = 12,
    VT_INITIAL_LIFTING_SPEED = 14,
    VT_WORK_UPGRADE_SPEED = 16
  };
  float rated_current() const {
    return GetField<float>(VT_RATED_CURRENT, 0.0f);
  }
  float overload_current() const {
    return GetField<float>(VT_OVERLOAD_CURRENT, 0.0f);
  }
  float overload_time() const {
    return GetField<float>(VT_OVERLOAD_TIME, 0.0f);
  }
  float uplink_timing_time() const {
    return GetField<float>(VT_UPLINK_TIMING_TIME, 0.0f);
  }
  float downlink_timing_time() const {
    return GetField<float>(VT_DOWNLINK_TIMING_TIME, 0.0f);
  }
  float initial_lifting_speed() const {
    return GetField<float>(VT_INITIAL_LIFTING_SPEED, 0.0f);
  }
  float work_upgrade_speed() const {
    return GetField<float>(VT_WORK_UPGRADE_SPEED, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_RATED_CURRENT) &&
           VerifyField<float>(verifier, VT_OVERLOAD_CURRENT) &&
           VerifyField<float>(verifier, VT_OVERLOAD_TIME) &&
           VerifyField<float>(verifier, VT_UPLINK_TIMING_TIME) &&
           VerifyField<float>(verifier, VT_DOWNLINK_TIMING_TIME) &&
           VerifyField<float>(verifier, VT_INITIAL_LIFTING_SPEED) &&
           VerifyField<float>(verifier, VT_WORK_UPGRADE_SPEED) &&
           verifier.EndTable();
  }
};

struct BrushWirePusherParamsBuilder {
  typedef BrushWirePusherParams Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rated_current(float rated_current) {
    fbb_.AddElement<float>(BrushWirePusherParams::VT_RATED_CURRENT, rated_current, 0.0f);
  }
  void add_overload_current(float overload_current) {
    fbb_.AddElement<float>(BrushWirePusherParams::VT_OVERLOAD_CURRENT, overload_current, 0.0f);
  }
  void add_overload_time(float overload_time) {
    fbb_.AddElement<float>(BrushWirePusherParams::VT_OVERLOAD_TIME, overload_time, 0.0f);
  }
  void add_uplink_timing_time(float uplink_timing_time) {
    fbb_.AddElement<float>(BrushWirePusherParams::VT_UPLINK_TIMING_TIME, uplink_timing_time, 0.0f);
  }
  void add_downlink_timing_time(float downlink_timing_time) {
    fbb_.AddElement<float>(BrushWirePusherParams::VT_DOWNLINK_TIMING_TIME, downlink_timing_time, 0.0f);
  }
  void add_initial_lifting_speed(float initial_lifting_speed) {
    fbb_.AddElement<float>(BrushWirePusherParams::VT_INITIAL_LIFTING_SPEED, initial_lifting_speed, 0.0f);
  }
  void add_work_upgrade_speed(float work_upgrade_speed) {
    fbb_.AddElement<float>(BrushWirePusherParams::VT_WORK_UPGRADE_SPEED, work_upgrade_speed, 0.0f);
  }
  explicit BrushWirePusherParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BrushWirePusherParamsBuilder &operator=(const BrushWirePusherParamsBuilder &);
  flatbuffers::Offset<BrushWirePusherParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BrushWirePusherParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<BrushWirePusherParams> CreateBrushWirePusherParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    float rated_current = 0.0f,
    float overload_current = 0.0f,
    float overload_time = 0.0f,
    float uplink_timing_time = 0.0f,
    float downlink_timing_time = 0.0f,
    float initial_lifting_speed = 0.0f,
    float work_upgrade_speed = 0.0f) {
  BrushWirePusherParamsBuilder builder_(_fbb);
  builder_.add_work_upgrade_speed(work_upgrade_speed);
  builder_.add_initial_lifting_speed(initial_lifting_speed);
  builder_.add_downlink_timing_time(downlink_timing_time);
  builder_.add_uplink_timing_time(uplink_timing_time);
  builder_.add_overload_time(overload_time);
  builder_.add_overload_current(overload_current);
  builder_.add_rated_current(rated_current);
  return builder_.Finish();
}

struct WaterHangingWirePusherParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WaterHangingWirePusherParamsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATED_CURRENT = 4,
    VT_OVERLOAD_CURRENT = 6,
    VT_OVERLOAD_TIME = 8,
    VT_UPLINK_TIMING_TIME = 10,
    VT_DOWNLINK_TIMING_TIME = 12,
    VT_UPLINK_START_DELAY_TIM = 14,
    VT_BACKWARD_RISING_DELAY_TIME = 16
  };
  float rated_current() const {
    return GetField<float>(VT_RATED_CURRENT, 0.0f);
  }
  float overload_current() const {
    return GetField<float>(VT_OVERLOAD_CURRENT, 0.0f);
  }
  float overload_time() const {
    return GetField<float>(VT_OVERLOAD_TIME, 0.0f);
  }
  float uplink_timing_time() const {
    return GetField<float>(VT_UPLINK_TIMING_TIME, 0.0f);
  }
  float downlink_timing_time() const {
    return GetField<float>(VT_DOWNLINK_TIMING_TIME, 0.0f);
  }
  float uplink_start_delay_tim() const {
    return GetField<float>(VT_UPLINK_START_DELAY_TIM, 0.0f);
  }
  float backward_rising_delay_time() const {
    return GetField<float>(VT_BACKWARD_RISING_DELAY_TIME, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_RATED_CURRENT) &&
           VerifyField<float>(verifier, VT_OVERLOAD_CURRENT) &&
           VerifyField<float>(verifier, VT_OVERLOAD_TIME) &&
           VerifyField<float>(verifier, VT_UPLINK_TIMING_TIME) &&
           VerifyField<float>(verifier, VT_DOWNLINK_TIMING_TIME) &&
           VerifyField<float>(verifier, VT_UPLINK_START_DELAY_TIM) &&
           VerifyField<float>(verifier, VT_BACKWARD_RISING_DELAY_TIME) &&
           verifier.EndTable();
  }
};

struct WaterHangingWirePusherParamsBuilder {
  typedef WaterHangingWirePusherParams Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rated_current(float rated_current) {
    fbb_.AddElement<float>(WaterHangingWirePusherParams::VT_RATED_CURRENT, rated_current, 0.0f);
  }
  void add_overload_current(float overload_current) {
    fbb_.AddElement<float>(WaterHangingWirePusherParams::VT_OVERLOAD_CURRENT, overload_current, 0.0f);
  }
  void add_overload_time(float overload_time) {
    fbb_.AddElement<float>(WaterHangingWirePusherParams::VT_OVERLOAD_TIME, overload_time, 0.0f);
  }
  void add_uplink_timing_time(float uplink_timing_time) {
    fbb_.AddElement<float>(WaterHangingWirePusherParams::VT_UPLINK_TIMING_TIME, uplink_timing_time, 0.0f);
  }
  void add_downlink_timing_time(float downlink_timing_time) {
    fbb_.AddElement<float>(WaterHangingWirePusherParams::VT_DOWNLINK_TIMING_TIME, downlink_timing_time, 0.0f);
  }
  void add_uplink_start_delay_tim(float uplink_start_delay_tim) {
    fbb_.AddElement<float>(WaterHangingWirePusherParams::VT_UPLINK_START_DELAY_TIM, uplink_start_delay_tim, 0.0f);
  }
  void add_backward_rising_delay_time(float backward_rising_delay_time) {
    fbb_.AddElement<float>(WaterHangingWirePusherParams::VT_BACKWARD_RISING_DELAY_TIME, backward_rising_delay_time, 0.0f);
  }
  explicit WaterHangingWirePusherParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WaterHangingWirePusherParamsBuilder &operator=(const WaterHangingWirePusherParamsBuilder &);
  flatbuffers::Offset<WaterHangingWirePusherParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WaterHangingWirePusherParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<WaterHangingWirePusherParams> CreateWaterHangingWirePusherParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    float rated_current = 0.0f,
    float overload_current = 0.0f,
    float overload_time = 0.0f,
    float uplink_timing_time = 0.0f,
    float downlink_timing_time = 0.0f,
    float uplink_start_delay_tim = 0.0f,
    float backward_rising_delay_time = 0.0f) {
  WaterHangingWirePusherParamsBuilder builder_(_fbb);
  builder_.add_backward_rising_delay_time(backward_rising_delay_time);
  builder_.add_uplink_start_delay_tim(uplink_start_delay_tim);
  builder_.add_downlink_timing_time(downlink_timing_time);
  builder_.add_uplink_timing_time(uplink_timing_time);
  builder_.add_overload_time(overload_time);
  builder_.add_overload_current(overload_current);
  builder_.add_rated_current(rated_current);
  return builder_.Finish();
}

struct SuctionPumpParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SuctionPumpParamsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATED_CURREN = 4,
    VT_OVERLOAD_CURRENT = 6,
    VT_OVERLOAD_TIM = 8,
    VT_FORWARD_STATE_OFF_DE = 10,
    VT_SHUTDOWN_DELAY_IN_BACKWARD_STATE = 12
  };
  float rated_curren() const {
    return GetField<float>(VT_RATED_CURREN, 0.0f);
  }
  float overload_current() const {
    return GetField<float>(VT_OVERLOAD_CURRENT, 0.0f);
  }
  float overload_tim() const {
    return GetField<float>(VT_OVERLOAD_TIM, 0.0f);
  }
  float forward_state_off_de() const {
    return GetField<float>(VT_FORWARD_STATE_OFF_DE, 0.0f);
  }
  float shutdown_delay_in_backward_state() const {
    return GetField<float>(VT_SHUTDOWN_DELAY_IN_BACKWARD_STATE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_RATED_CURREN) &&
           VerifyField<float>(verifier, VT_OVERLOAD_CURRENT) &&
           VerifyField<float>(verifier, VT_OVERLOAD_TIM) &&
           VerifyField<float>(verifier, VT_FORWARD_STATE_OFF_DE) &&
           VerifyField<float>(verifier, VT_SHUTDOWN_DELAY_IN_BACKWARD_STATE) &&
           verifier.EndTable();
  }
};

struct SuctionPumpParamsBuilder {
  typedef SuctionPumpParams Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rated_curren(float rated_curren) {
    fbb_.AddElement<float>(SuctionPumpParams::VT_RATED_CURREN, rated_curren, 0.0f);
  }
  void add_overload_current(float overload_current) {
    fbb_.AddElement<float>(SuctionPumpParams::VT_OVERLOAD_CURRENT, overload_current, 0.0f);
  }
  void add_overload_tim(float overload_tim) {
    fbb_.AddElement<float>(SuctionPumpParams::VT_OVERLOAD_TIM, overload_tim, 0.0f);
  }
  void add_forward_state_off_de(float forward_state_off_de) {
    fbb_.AddElement<float>(SuctionPumpParams::VT_FORWARD_STATE_OFF_DE, forward_state_off_de, 0.0f);
  }
  void add_shutdown_delay_in_backward_state(float shutdown_delay_in_backward_state) {
    fbb_.AddElement<float>(SuctionPumpParams::VT_SHUTDOWN_DELAY_IN_BACKWARD_STATE, shutdown_delay_in_backward_state, 0.0f);
  }
  explicit SuctionPumpParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SuctionPumpParamsBuilder &operator=(const SuctionPumpParamsBuilder &);
  flatbuffers::Offset<SuctionPumpParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SuctionPumpParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<SuctionPumpParams> CreateSuctionPumpParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    float rated_curren = 0.0f,
    float overload_current = 0.0f,
    float overload_tim = 0.0f,
    float forward_state_off_de = 0.0f,
    float shutdown_delay_in_backward_state = 0.0f) {
  SuctionPumpParamsBuilder builder_(_fbb);
  builder_.add_shutdown_delay_in_backward_state(shutdown_delay_in_backward_state);
  builder_.add_forward_state_off_de(forward_state_off_de);
  builder_.add_overload_tim(overload_tim);
  builder_.add_overload_current(overload_current);
  builder_.add_rated_curren(rated_curren);
  return builder_.Finish();
}

struct CleanWaterPumpParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CleanWaterPumpParamsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WATER_LEVEL = 4,
    VT_GEAR_1_FLOW = 6,
    VT_GEAR_2_FLOW = 8
  };
  float water_level() const {
    return GetField<float>(VT_WATER_LEVEL, 0.0f);
  }
  float gear_1_flow() const {
    return GetField<float>(VT_GEAR_1_FLOW, 0.0f);
  }
  float gear_2_flow() const {
    return GetField<float>(VT_GEAR_2_FLOW, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_WATER_LEVEL) &&
           VerifyField<float>(verifier, VT_GEAR_1_FLOW) &&
           VerifyField<float>(verifier, VT_GEAR_2_FLOW) &&
           verifier.EndTable();
  }
};

struct CleanWaterPumpParamsBuilder {
  typedef CleanWaterPumpParams Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_water_level(float water_level) {
    fbb_.AddElement<float>(CleanWaterPumpParams::VT_WATER_LEVEL, water_level, 0.0f);
  }
  void add_gear_1_flow(float gear_1_flow) {
    fbb_.AddElement<float>(CleanWaterPumpParams::VT_GEAR_1_FLOW, gear_1_flow, 0.0f);
  }
  void add_gear_2_flow(float gear_2_flow) {
    fbb_.AddElement<float>(CleanWaterPumpParams::VT_GEAR_2_FLOW, gear_2_flow, 0.0f);
  }
  explicit CleanWaterPumpParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CleanWaterPumpParamsBuilder &operator=(const CleanWaterPumpParamsBuilder &);
  flatbuffers::Offset<CleanWaterPumpParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CleanWaterPumpParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<CleanWaterPumpParams> CreateCleanWaterPumpParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    float water_level = 0.0f,
    float gear_1_flow = 0.0f,
    float gear_2_flow = 0.0f) {
  CleanWaterPumpParamsBuilder builder_(_fbb);
  builder_.add_gear_2_flow(gear_2_flow);
  builder_.add_gear_1_flow(gear_1_flow);
  builder_.add_water_level(water_level);
  return builder_.Finish();
}

struct BatteryParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatteryParamsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BATTERY_DISPLAY_MODE = 4,
    VT_GEAR_1_VOLTAGE = 6,
    VT_GEAR_2_VOLTAGE = 8,
    VT_GEAR_3_VOLTAGE = 10,
    VT_GEAR_4_VOLTAGE = 12,
    VT_GEAR_5_VOLTAGE = 14
  };
  bool battery_display_mode() const {
    return GetField<uint8_t>(VT_BATTERY_DISPLAY_MODE, 0) != 0;
  }
  float gear_1_voltage() const {
    return GetField<float>(VT_GEAR_1_VOLTAGE, 0.0f);
  }
  float gear_2_voltage() const {
    return GetField<float>(VT_GEAR_2_VOLTAGE, 0.0f);
  }
  float gear_3_voltage() const {
    return GetField<float>(VT_GEAR_3_VOLTAGE, 0.0f);
  }
  float gear_4_voltage() const {
    return GetField<float>(VT_GEAR_4_VOLTAGE, 0.0f);
  }
  float gear_5_voltage() const {
    return GetField<float>(VT_GEAR_5_VOLTAGE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BATTERY_DISPLAY_MODE) &&
           VerifyField<float>(verifier, VT_GEAR_1_VOLTAGE) &&
           VerifyField<float>(verifier, VT_GEAR_2_VOLTAGE) &&
           VerifyField<float>(verifier, VT_GEAR_3_VOLTAGE) &&
           VerifyField<float>(verifier, VT_GEAR_4_VOLTAGE) &&
           VerifyField<float>(verifier, VT_GEAR_5_VOLTAGE) &&
           verifier.EndTable();
  }
};

struct BatteryParamsBuilder {
  typedef BatteryParams Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_battery_display_mode(bool battery_display_mode) {
    fbb_.AddElement<uint8_t>(BatteryParams::VT_BATTERY_DISPLAY_MODE, static_cast<uint8_t>(battery_display_mode), 0);
  }
  void add_gear_1_voltage(float gear_1_voltage) {
    fbb_.AddElement<float>(BatteryParams::VT_GEAR_1_VOLTAGE, gear_1_voltage, 0.0f);
  }
  void add_gear_2_voltage(float gear_2_voltage) {
    fbb_.AddElement<float>(BatteryParams::VT_GEAR_2_VOLTAGE, gear_2_voltage, 0.0f);
  }
  void add_gear_3_voltage(float gear_3_voltage) {
    fbb_.AddElement<float>(BatteryParams::VT_GEAR_3_VOLTAGE, gear_3_voltage, 0.0f);
  }
  void add_gear_4_voltage(float gear_4_voltage) {
    fbb_.AddElement<float>(BatteryParams::VT_GEAR_4_VOLTAGE, gear_4_voltage, 0.0f);
  }
  void add_gear_5_voltage(float gear_5_voltage) {
    fbb_.AddElement<float>(BatteryParams::VT_GEAR_5_VOLTAGE, gear_5_voltage, 0.0f);
  }
  explicit BatteryParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BatteryParamsBuilder &operator=(const BatteryParamsBuilder &);
  flatbuffers::Offset<BatteryParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatteryParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatteryParams> CreateBatteryParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool battery_display_mode = false,
    float gear_1_voltage = 0.0f,
    float gear_2_voltage = 0.0f,
    float gear_3_voltage = 0.0f,
    float gear_4_voltage = 0.0f,
    float gear_5_voltage = 0.0f) {
  BatteryParamsBuilder builder_(_fbb);
  builder_.add_gear_5_voltage(gear_5_voltage);
  builder_.add_gear_4_voltage(gear_4_voltage);
  builder_.add_gear_3_voltage(gear_3_voltage);
  builder_.add_gear_2_voltage(gear_2_voltage);
  builder_.add_gear_1_voltage(gear_1_voltage);
  builder_.add_battery_display_mode(battery_display_mode);
  return builder_.Finish();
}

struct MachineParamRqst FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MachineParamRqstBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_PARAM = 6
  };
  swr::MachineParamsModule type() const {
    return static_cast<swr::MachineParamsModule>(GetField<int8_t>(VT_TYPE, 0));
  }
  const swr::ParamData *param() const {
    return GetPointer<const swr::ParamData *>(VT_PARAM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_PARAM) &&
           verifier.VerifyTable(param()) &&
           verifier.EndTable();
  }
};

struct MachineParamRqstBuilder {
  typedef MachineParamRqst Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(swr::MachineParamsModule type) {
    fbb_.AddElement<int8_t>(MachineParamRqst::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_param(flatbuffers::Offset<swr::ParamData> param) {
    fbb_.AddOffset(MachineParamRqst::VT_PARAM, param);
  }
  explicit MachineParamRqstBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MachineParamRqstBuilder &operator=(const MachineParamRqstBuilder &);
  flatbuffers::Offset<MachineParamRqst> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MachineParamRqst>(end);
    return o;
  }
};

inline flatbuffers::Offset<MachineParamRqst> CreateMachineParamRqst(
    flatbuffers::FlatBufferBuilder &_fbb,
    swr::MachineParamsModule type = swr::MachineParamsModule_WalkingMotor,
    flatbuffers::Offset<swr::ParamData> param = 0) {
  MachineParamRqstBuilder builder_(_fbb);
  builder_.add_param(param);
  builder_.add_type(type);
  return builder_.Finish();
}

struct MachineParamResp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MachineParamRespBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_DATA_TYPE = 6,
    VT_DATA = 8
  };
  swr::MachineParamsModule type() const {
    return static_cast<swr::MachineParamsModule>(GetField<int8_t>(VT_TYPE, 0));
  }
  swr::MachineParamData data_type() const {
    return static_cast<swr::MachineParamData>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const swr::WalkingMotorParams *data_as_WalkingMotorParams() const {
    return data_type() == swr::MachineParamData_WalkingMotorParams ? static_cast<const swr::WalkingMotorParams *>(data()) : nullptr;
  }
  const swr::LeftAndRightBrushMotorParams *data_as_LeftAndRightBrushMotorParams() const {
    return data_type() == swr::MachineParamData_LeftAndRightBrushMotorParams ? static_cast<const swr::LeftAndRightBrushMotorParams *>(data()) : nullptr;
  }
  const swr::MainBrushMotorParams *data_as_MainBrushMotorParams() const {
    return data_type() == swr::MachineParamData_MainBrushMotorParams ? static_cast<const swr::MainBrushMotorParams *>(data()) : nullptr;
  }
  const swr::BrushWirePusherParams *data_as_BrushWirePusherParams() const {
    return data_type() == swr::MachineParamData_BrushWirePusherParams ? static_cast<const swr::BrushWirePusherParams *>(data()) : nullptr;
  }
  const swr::WaterHangingWirePusherParams *data_as_WaterHangingWirePusherParams() const {
    return data_type() == swr::MachineParamData_WaterHangingWirePusherParams ? static_cast<const swr::WaterHangingWirePusherParams *>(data()) : nullptr;
  }
  const swr::SuctionPumpParams *data_as_SuctionPumpParams() const {
    return data_type() == swr::MachineParamData_SuctionPumpParams ? static_cast<const swr::SuctionPumpParams *>(data()) : nullptr;
  }
  const swr::CleanWaterPumpParams *data_as_CleanWaterPumpParams() const {
    return data_type() == swr::MachineParamData_CleanWaterPumpParams ? static_cast<const swr::CleanWaterPumpParams *>(data()) : nullptr;
  }
  const swr::BatteryParams *data_as_BatteryParams() const {
    return data_type() == swr::MachineParamData_BatteryParams ? static_cast<const swr::BatteryParams *>(data()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyMachineParamData(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

template<> inline const swr::WalkingMotorParams *MachineParamResp::data_as<swr::WalkingMotorParams>() const {
  return data_as_WalkingMotorParams();
}

template<> inline const swr::LeftAndRightBrushMotorParams *MachineParamResp::data_as<swr::LeftAndRightBrushMotorParams>() const {
  return data_as_LeftAndRightBrushMotorParams();
}

template<> inline const swr::MainBrushMotorParams *MachineParamResp::data_as<swr::MainBrushMotorParams>() const {
  return data_as_MainBrushMotorParams();
}

template<> inline const swr::BrushWirePusherParams *MachineParamResp::data_as<swr::BrushWirePusherParams>() const {
  return data_as_BrushWirePusherParams();
}

template<> inline const swr::WaterHangingWirePusherParams *MachineParamResp::data_as<swr::WaterHangingWirePusherParams>() const {
  return data_as_WaterHangingWirePusherParams();
}

template<> inline const swr::SuctionPumpParams *MachineParamResp::data_as<swr::SuctionPumpParams>() const {
  return data_as_SuctionPumpParams();
}

template<> inline const swr::CleanWaterPumpParams *MachineParamResp::data_as<swr::CleanWaterPumpParams>() const {
  return data_as_CleanWaterPumpParams();
}

template<> inline const swr::BatteryParams *MachineParamResp::data_as<swr::BatteryParams>() const {
  return data_as_BatteryParams();
}

struct MachineParamRespBuilder {
  typedef MachineParamResp Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(swr::MachineParamsModule type) {
    fbb_.AddElement<int8_t>(MachineParamResp::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_data_type(swr::MachineParamData data_type) {
    fbb_.AddElement<uint8_t>(MachineParamResp::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(flatbuffers::Offset<void> data) {
    fbb_.AddOffset(MachineParamResp::VT_DATA, data);
  }
  explicit MachineParamRespBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MachineParamRespBuilder &operator=(const MachineParamRespBuilder &);
  flatbuffers::Offset<MachineParamResp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MachineParamResp>(end);
    return o;
  }
};

inline flatbuffers::Offset<MachineParamResp> CreateMachineParamResp(
    flatbuffers::FlatBufferBuilder &_fbb,
    swr::MachineParamsModule type = swr::MachineParamsModule_WalkingMotor,
    swr::MachineParamData data_type = swr::MachineParamData_NONE,
    flatbuffers::Offset<void> data = 0) {
  MachineParamRespBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  builder_.add_type(type);
  return builder_.Finish();
}

struct WorkingModeData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WorkingModeDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ECONOMIZE = 4,
    VT_STRONG = 6
  };
  const swr::ModeSetting *economize() const {
    return GetPointer<const swr::ModeSetting *>(VT_ECONOMIZE);
  }
  const swr::ModeSetting *strong() const {
    return GetPointer<const swr::ModeSetting *>(VT_STRONG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ECONOMIZE) &&
           verifier.VerifyTable(economize()) &&
           VerifyOffset(verifier, VT_STRONG) &&
           verifier.VerifyTable(strong()) &&
           verifier.EndTable();
  }
};

struct WorkingModeDataBuilder {
  typedef WorkingModeData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_economize(flatbuffers::Offset<swr::ModeSetting> economize) {
    fbb_.AddOffset(WorkingModeData::VT_ECONOMIZE, economize);
  }
  void add_strong(flatbuffers::Offset<swr::ModeSetting> strong) {
    fbb_.AddOffset(WorkingModeData::VT_STRONG, strong);
  }
  explicit WorkingModeDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WorkingModeDataBuilder &operator=(const WorkingModeDataBuilder &);
  flatbuffers::Offset<WorkingModeData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WorkingModeData>(end);
    return o;
  }
};

inline flatbuffers::Offset<WorkingModeData> CreateWorkingModeData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<swr::ModeSetting> economize = 0,
    flatbuffers::Offset<swr::ModeSetting> strong = 0) {
  WorkingModeDataBuilder builder_(_fbb);
  builder_.add_strong(strong);
  builder_.add_economize(economize);
  return builder_.Finish();
}

struct WorkingHoursData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WorkingHoursDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADMIN = 4,
    VT_CUSTOMER = 6
  };
  const swr::HoursData *admin() const {
    return GetPointer<const swr::HoursData *>(VT_ADMIN);
  }
  const swr::HoursData *customer() const {
    return GetPointer<const swr::HoursData *>(VT_CUSTOMER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ADMIN) &&
           verifier.VerifyTable(admin()) &&
           VerifyOffset(verifier, VT_CUSTOMER) &&
           verifier.VerifyTable(customer()) &&
           verifier.EndTable();
  }
};

struct WorkingHoursDataBuilder {
  typedef WorkingHoursData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_admin(flatbuffers::Offset<swr::HoursData> admin) {
    fbb_.AddOffset(WorkingHoursData::VT_ADMIN, admin);
  }
  void add_customer(flatbuffers::Offset<swr::HoursData> customer) {
    fbb_.AddOffset(WorkingHoursData::VT_CUSTOMER, customer);
  }
  explicit WorkingHoursDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WorkingHoursDataBuilder &operator=(const WorkingHoursDataBuilder &);
  flatbuffers::Offset<WorkingHoursData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WorkingHoursData>(end);
    return o;
  }
};

inline flatbuffers::Offset<WorkingHoursData> CreateWorkingHoursData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<swr::HoursData> admin = 0,
    flatbuffers::Offset<swr::HoursData> customer = 0) {
  WorkingHoursDataBuilder builder_(_fbb);
  builder_.add_customer(customer);
  builder_.add_admin(admin);
  return builder_.Finish();
}

struct WirePusher FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WirePusherBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPER = 4
  };
  swr::WirePusherOper oper() const {
    return static_cast<swr::WirePusherOper>(GetField<int8_t>(VT_OPER, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OPER) &&
           verifier.EndTable();
  }
};

struct WirePusherBuilder {
  typedef WirePusher Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_oper(swr::WirePusherOper oper) {
    fbb_.AddElement<int8_t>(WirePusher::VT_OPER, static_cast<int8_t>(oper), 0);
  }
  explicit WirePusherBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WirePusherBuilder &operator=(const WirePusherBuilder &);
  flatbuffers::Offset<WirePusher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WirePusher>(end);
    return o;
  }
};

inline flatbuffers::Offset<WirePusher> CreateWirePusher(
    flatbuffers::FlatBufferBuilder &_fbb,
    swr::WirePusherOper oper = swr::WirePusherOper_Up) {
  WirePusherBuilder builder_(_fbb);
  builder_.add_oper(oper);
  return builder_.Finish();
}

struct WaterPumpGear FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WaterPumpGearBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPER = 4
  };
  swr::WaterPumpGearOper oper() const {
    return static_cast<swr::WaterPumpGearOper>(GetField<int8_t>(VT_OPER, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OPER) &&
           verifier.EndTable();
  }
};

struct WaterPumpGearBuilder {
  typedef WaterPumpGear Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_oper(swr::WaterPumpGearOper oper) {
    fbb_.AddElement<int8_t>(WaterPumpGear::VT_OPER, static_cast<int8_t>(oper), 0);
  }
  explicit WaterPumpGearBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WaterPumpGearBuilder &operator=(const WaterPumpGearBuilder &);
  flatbuffers::Offset<WaterPumpGear> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WaterPumpGear>(end);
    return o;
  }
};

inline flatbuffers::Offset<WaterPumpGear> CreateWaterPumpGear(
    flatbuffers::FlatBufferBuilder &_fbb,
    swr::WaterPumpGearOper oper = swr::WaterPumpGearOper_Off) {
  WaterPumpGearBuilder builder_(_fbb);
  builder_.add_oper(oper);
  return builder_.Finish();
}

struct Brake FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BrakeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPER = 4
  };
  swr::BrakeOper oper() const {
    return static_cast<swr::BrakeOper>(GetField<int8_t>(VT_OPER, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OPER) &&
           verifier.EndTable();
  }
};

struct BrakeBuilder {
  typedef Brake Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_oper(swr::BrakeOper oper) {
    fbb_.AddElement<int8_t>(Brake::VT_OPER, static_cast<int8_t>(oper), 0);
  }
  explicit BrakeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BrakeBuilder &operator=(const BrakeBuilder &);
  flatbuffers::Offset<Brake> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Brake>(end);
    return o;
  }
};

inline flatbuffers::Offset<Brake> CreateBrake(
    flatbuffers::FlatBufferBuilder &_fbb,
    swr::BrakeOper oper = swr::BrakeOper_Brake) {
  BrakeBuilder builder_(_fbb);
  builder_.add_oper(oper);
  return builder_.Finish();
}

struct LightBelt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LightBeltBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPER = 4
  };
  swr::LightBeltOper oper() const {
    return static_cast<swr::LightBeltOper>(GetField<int8_t>(VT_OPER, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OPER) &&
           verifier.EndTable();
  }
};

struct LightBeltBuilder {
  typedef LightBelt Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_oper(swr::LightBeltOper oper) {
    fbb_.AddElement<int8_t>(LightBelt::VT_OPER, static_cast<int8_t>(oper), 0);
  }
  explicit LightBeltBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LightBeltBuilder &operator=(const LightBeltBuilder &);
  flatbuffers::Offset<LightBelt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LightBelt>(end);
    return o;
  }
};

inline flatbuffers::Offset<LightBelt> CreateLightBelt(
    flatbuffers::FlatBufferBuilder &_fbb,
    swr::LightBeltOper oper = swr::LightBeltOper_Off) {
  LightBeltBuilder builder_(_fbb);
  builder_.add_oper(oper);
  return builder_.Finish();
}

struct TestingItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TestingItemBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_DATA_TYPE = 6,
    VT_DATA = 8
  };
  swr::TestingItemType type() const {
    return static_cast<swr::TestingItemType>(GetField<int8_t>(VT_TYPE, 0));
  }
  swr::TestingItemData data_type() const {
    return static_cast<swr::TestingItemData>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const swr::Switch *data_as_Switch() const {
    return data_type() == swr::TestingItemData_Switch ? static_cast<const swr::Switch *>(data()) : nullptr;
  }
  const swr::WirePusher *data_as_WirePusher() const {
    return data_type() == swr::TestingItemData_WirePusher ? static_cast<const swr::WirePusher *>(data()) : nullptr;
  }
  const swr::WaterPumpGear *data_as_WaterPumpGear() const {
    return data_type() == swr::TestingItemData_WaterPumpGear ? static_cast<const swr::WaterPumpGear *>(data()) : nullptr;
  }
  const swr::Brake *data_as_Brake() const {
    return data_type() == swr::TestingItemData_Brake ? static_cast<const swr::Brake *>(data()) : nullptr;
  }
  const swr::LightBelt *data_as_LightBelt() const {
    return data_type() == swr::TestingItemData_LightBelt ? static_cast<const swr::LightBelt *>(data()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyTestingItemData(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

template<> inline const swr::Switch *TestingItem::data_as<swr::Switch>() const {
  return data_as_Switch();
}

template<> inline const swr::WirePusher *TestingItem::data_as<swr::WirePusher>() const {
  return data_as_WirePusher();
}

template<> inline const swr::WaterPumpGear *TestingItem::data_as<swr::WaterPumpGear>() const {
  return data_as_WaterPumpGear();
}

template<> inline const swr::Brake *TestingItem::data_as<swr::Brake>() const {
  return data_as_Brake();
}

template<> inline const swr::LightBelt *TestingItem::data_as<swr::LightBelt>() const {
  return data_as_LightBelt();
}

struct TestingItemBuilder {
  typedef TestingItem Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(swr::TestingItemType type) {
    fbb_.AddElement<int8_t>(TestingItem::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_data_type(swr::TestingItemData data_type) {
    fbb_.AddElement<uint8_t>(TestingItem::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(flatbuffers::Offset<void> data) {
    fbb_.AddOffset(TestingItem::VT_DATA, data);
  }
  explicit TestingItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TestingItemBuilder &operator=(const TestingItemBuilder &);
  flatbuffers::Offset<TestingItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TestingItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<TestingItem> CreateTestingItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    swr::TestingItemType type = swr::TestingItemType_MainBrushMotor,
    swr::TestingItemData data_type = swr::TestingItemData_NONE,
    flatbuffers::Offset<void> data = 0) {
  TestingItemBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  builder_.add_type(type);
  return builder_.Finish();
}

struct EquipmentTestingResp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EquipmentTestingRespBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAIN_BRUSH_MOTOR = 4,
    VT_LEFT_BRUSH_MOTOR = 6,
    VT_RIGHT_BRUSH_MOTOR = 8,
    VT_SUCTION_PUMP = 10,
    VT_HORN = 12,
    VT_BRUSH_WIRE_PUSHER = 14,
    VT_WATER_HANGING_WIRE_PUSHER = 16,
    VT_WATER_PUMP_GEAR = 18,
    VT_LEFT_BRAKE_ASSEMBLY = 20,
    VT_RIGHT_BRAKE_ASSEMBLY = 22,
    VT_LIGHT_BELT = 24
  };
  bool main_brush_motor() const {
    return GetField<uint8_t>(VT_MAIN_BRUSH_MOTOR, 0) != 0;
  }
  bool left_brush_motor() const {
    return GetField<uint8_t>(VT_LEFT_BRUSH_MOTOR, 0) != 0;
  }
  bool right_brush_motor() const {
    return GetField<uint8_t>(VT_RIGHT_BRUSH_MOTOR, 0) != 0;
  }
  bool suction_pump() const {
    return GetField<uint8_t>(VT_SUCTION_PUMP, 0) != 0;
  }
  bool horn() const {
    return GetField<uint8_t>(VT_HORN, 0) != 0;
  }
  swr::WirePusherOper brush_wire_pusher() const {
    return static_cast<swr::WirePusherOper>(GetField<int8_t>(VT_BRUSH_WIRE_PUSHER, 0));
  }
  swr::WirePusherOper water_hanging_wire_pusher() const {
    return static_cast<swr::WirePusherOper>(GetField<int8_t>(VT_WATER_HANGING_WIRE_PUSHER, 0));
  }
  swr::WaterPumpGearOper water_pump_gear() const {
    return static_cast<swr::WaterPumpGearOper>(GetField<int8_t>(VT_WATER_PUMP_GEAR, 0));
  }
  swr::BrakeOper left_brake_assembly() const {
    return static_cast<swr::BrakeOper>(GetField<int8_t>(VT_LEFT_BRAKE_ASSEMBLY, 0));
  }
  swr::BrakeOper right_brake_assembly() const {
    return static_cast<swr::BrakeOper>(GetField<int8_t>(VT_RIGHT_BRAKE_ASSEMBLY, 0));
  }
  swr::LightBeltOper light_belt() const {
    return static_cast<swr::LightBeltOper>(GetField<int8_t>(VT_LIGHT_BELT, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MAIN_BRUSH_MOTOR) &&
           VerifyField<uint8_t>(verifier, VT_LEFT_BRUSH_MOTOR) &&
           VerifyField<uint8_t>(verifier, VT_RIGHT_BRUSH_MOTOR) &&
           VerifyField<uint8_t>(verifier, VT_SUCTION_PUMP) &&
           VerifyField<uint8_t>(verifier, VT_HORN) &&
           VerifyField<int8_t>(verifier, VT_BRUSH_WIRE_PUSHER) &&
           VerifyField<int8_t>(verifier, VT_WATER_HANGING_WIRE_PUSHER) &&
           VerifyField<int8_t>(verifier, VT_WATER_PUMP_GEAR) &&
           VerifyField<int8_t>(verifier, VT_LEFT_BRAKE_ASSEMBLY) &&
           VerifyField<int8_t>(verifier, VT_RIGHT_BRAKE_ASSEMBLY) &&
           VerifyField<int8_t>(verifier, VT_LIGHT_BELT) &&
           verifier.EndTable();
  }
};

struct EquipmentTestingRespBuilder {
  typedef EquipmentTestingResp Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_main_brush_motor(bool main_brush_motor) {
    fbb_.AddElement<uint8_t>(EquipmentTestingResp::VT_MAIN_BRUSH_MOTOR, static_cast<uint8_t>(main_brush_motor), 0);
  }
  void add_left_brush_motor(bool left_brush_motor) {
    fbb_.AddElement<uint8_t>(EquipmentTestingResp::VT_LEFT_BRUSH_MOTOR, static_cast<uint8_t>(left_brush_motor), 0);
  }
  void add_right_brush_motor(bool right_brush_motor) {
    fbb_.AddElement<uint8_t>(EquipmentTestingResp::VT_RIGHT_BRUSH_MOTOR, static_cast<uint8_t>(right_brush_motor), 0);
  }
  void add_suction_pump(bool suction_pump) {
    fbb_.AddElement<uint8_t>(EquipmentTestingResp::VT_SUCTION_PUMP, static_cast<uint8_t>(suction_pump), 0);
  }
  void add_horn(bool horn) {
    fbb_.AddElement<uint8_t>(EquipmentTestingResp::VT_HORN, static_cast<uint8_t>(horn), 0);
  }
  void add_brush_wire_pusher(swr::WirePusherOper brush_wire_pusher) {
    fbb_.AddElement<int8_t>(EquipmentTestingResp::VT_BRUSH_WIRE_PUSHER, static_cast<int8_t>(brush_wire_pusher), 0);
  }
  void add_water_hanging_wire_pusher(swr::WirePusherOper water_hanging_wire_pusher) {
    fbb_.AddElement<int8_t>(EquipmentTestingResp::VT_WATER_HANGING_WIRE_PUSHER, static_cast<int8_t>(water_hanging_wire_pusher), 0);
  }
  void add_water_pump_gear(swr::WaterPumpGearOper water_pump_gear) {
    fbb_.AddElement<int8_t>(EquipmentTestingResp::VT_WATER_PUMP_GEAR, static_cast<int8_t>(water_pump_gear), 0);
  }
  void add_left_brake_assembly(swr::BrakeOper left_brake_assembly) {
    fbb_.AddElement<int8_t>(EquipmentTestingResp::VT_LEFT_BRAKE_ASSEMBLY, static_cast<int8_t>(left_brake_assembly), 0);
  }
  void add_right_brake_assembly(swr::BrakeOper right_brake_assembly) {
    fbb_.AddElement<int8_t>(EquipmentTestingResp::VT_RIGHT_BRAKE_ASSEMBLY, static_cast<int8_t>(right_brake_assembly), 0);
  }
  void add_light_belt(swr::LightBeltOper light_belt) {
    fbb_.AddElement<int8_t>(EquipmentTestingResp::VT_LIGHT_BELT, static_cast<int8_t>(light_belt), 0);
  }
  explicit EquipmentTestingRespBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EquipmentTestingRespBuilder &operator=(const EquipmentTestingRespBuilder &);
  flatbuffers::Offset<EquipmentTestingResp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EquipmentTestingResp>(end);
    return o;
  }
};

inline flatbuffers::Offset<EquipmentTestingResp> CreateEquipmentTestingResp(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool main_brush_motor = false,
    bool left_brush_motor = false,
    bool right_brush_motor = false,
    bool suction_pump = false,
    bool horn = false,
    swr::WirePusherOper brush_wire_pusher = swr::WirePusherOper_Up,
    swr::WirePusherOper water_hanging_wire_pusher = swr::WirePusherOper_Up,
    swr::WaterPumpGearOper water_pump_gear = swr::WaterPumpGearOper_Off,
    swr::BrakeOper left_brake_assembly = swr::BrakeOper_Brake,
    swr::BrakeOper right_brake_assembly = swr::BrakeOper_Brake,
    swr::LightBeltOper light_belt = swr::LightBeltOper_Off) {
  EquipmentTestingRespBuilder builder_(_fbb);
  builder_.add_light_belt(light_belt);
  builder_.add_right_brake_assembly(right_brake_assembly);
  builder_.add_left_brake_assembly(left_brake_assembly);
  builder_.add_water_pump_gear(water_pump_gear);
  builder_.add_water_hanging_wire_pusher(water_hanging_wire_pusher);
  builder_.add_brush_wire_pusher(brush_wire_pusher);
  builder_.add_horn(horn);
  builder_.add_suction_pump(suction_pump);
  builder_.add_right_brush_motor(right_brush_motor);
  builder_.add_left_brush_motor(left_brush_motor);
  builder_.add_main_brush_motor(main_brush_motor);
  return builder_.Finish();
}

struct FaultSettingData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FaultSettingDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR = 4,
    VT_STATE = 6
  };
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  bool state() const {
    return GetField<uint8_t>(VT_STATE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           VerifyField<uint8_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
};

struct FaultSettingDataBuilder {
  typedef FaultSettingData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(FaultSettingData::VT_ERROR, error, 0);
  }
  void add_state(bool state) {
    fbb_.AddElement<uint8_t>(FaultSettingData::VT_STATE, static_cast<uint8_t>(state), 0);
  }
  explicit FaultSettingDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FaultSettingDataBuilder &operator=(const FaultSettingDataBuilder &);
  flatbuffers::Offset<FaultSettingData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FaultSettingData>(end);
    return o;
  }
};

inline flatbuffers::Offset<FaultSettingData> CreateFaultSettingData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t error = 0,
    bool state = false) {
  FaultSettingDataBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_state(state);
  return builder_.Finish();
}

struct FaultSettingResp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FaultSettingRespBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FAULT_SETTING_LIST = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<swr::FaultSettingData>> *fault_setting_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<swr::FaultSettingData>> *>(VT_FAULT_SETTING_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FAULT_SETTING_LIST) &&
           verifier.VerifyVector(fault_setting_list()) &&
           verifier.VerifyVectorOfTables(fault_setting_list()) &&
           verifier.EndTable();
  }
};

struct FaultSettingRespBuilder {
  typedef FaultSettingResp Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fault_setting_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<swr::FaultSettingData>>> fault_setting_list) {
    fbb_.AddOffset(FaultSettingResp::VT_FAULT_SETTING_LIST, fault_setting_list);
  }
  explicit FaultSettingRespBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FaultSettingRespBuilder &operator=(const FaultSettingRespBuilder &);
  flatbuffers::Offset<FaultSettingResp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FaultSettingResp>(end);
    return o;
  }
};

inline flatbuffers::Offset<FaultSettingResp> CreateFaultSettingResp(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<swr::FaultSettingData>>> fault_setting_list = 0) {
  FaultSettingRespBuilder builder_(_fbb);
  builder_.add_fault_setting_list(fault_setting_list);
  return builder_.Finish();
}

inline flatbuffers::Offset<FaultSettingResp> CreateFaultSettingRespDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<swr::FaultSettingData>> *fault_setting_list = nullptr) {
  auto fault_setting_list__ = fault_setting_list ? _fbb.CreateVector<flatbuffers::Offset<swr::FaultSettingData>>(*fault_setting_list) : 0;
  return swr::CreateFaultSettingResp(
      _fbb,
      fault_setting_list__);
}

struct ModeSetting FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModeSettingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WALKING_SPEED = 4,
    VT_MAIN_BRUSH_PRESSURE = 6,
    VT_WATER_VOLUME = 8
  };
  int16_t walking_speed() const {
    return GetField<int16_t>(VT_WALKING_SPEED, 0);
  }
  int16_t main_brush_pressure() const {
    return GetField<int16_t>(VT_MAIN_BRUSH_PRESSURE, 0);
  }
  int16_t water_volume() const {
    return GetField<int16_t>(VT_WATER_VOLUME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_WALKING_SPEED) &&
           VerifyField<int16_t>(verifier, VT_MAIN_BRUSH_PRESSURE) &&
           VerifyField<int16_t>(verifier, VT_WATER_VOLUME) &&
           verifier.EndTable();
  }
};

struct ModeSettingBuilder {
  typedef ModeSetting Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_walking_speed(int16_t walking_speed) {
    fbb_.AddElement<int16_t>(ModeSetting::VT_WALKING_SPEED, walking_speed, 0);
  }
  void add_main_brush_pressure(int16_t main_brush_pressure) {
    fbb_.AddElement<int16_t>(ModeSetting::VT_MAIN_BRUSH_PRESSURE, main_brush_pressure, 0);
  }
  void add_water_volume(int16_t water_volume) {
    fbb_.AddElement<int16_t>(ModeSetting::VT_WATER_VOLUME, water_volume, 0);
  }
  explicit ModeSettingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ModeSettingBuilder &operator=(const ModeSettingBuilder &);
  flatbuffers::Offset<ModeSetting> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ModeSetting>(end);
    return o;
  }
};

inline flatbuffers::Offset<ModeSetting> CreateModeSetting(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t walking_speed = 0,
    int16_t main_brush_pressure = 0,
    int16_t water_volume = 0) {
  ModeSettingBuilder builder_(_fbb);
  builder_.add_water_volume(water_volume);
  builder_.add_main_brush_pressure(main_brush_pressure);
  builder_.add_walking_speed(walking_speed);
  return builder_.Finish();
}

struct RecordData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RecordDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4,
    VT_START_TIME = 6,
    VT_STOP_TIME = 8,
    VT_RUN_TIME = 10,
    VT_CLEAN_AREA = 12,
    VT_MAP_AREA = 14
  };
  swr::IntelligenceMode mode() const {
    return static_cast<swr::IntelligenceMode>(GetField<int8_t>(VT_MODE, 0));
  }
  int64_t start_time() const {
    return GetField<int64_t>(VT_START_TIME, 0);
  }
  int64_t stop_time() const {
    return GetField<int64_t>(VT_STOP_TIME, 0);
  }
  int64_t run_time() const {
    return GetField<int64_t>(VT_RUN_TIME, 0);
  }
  int64_t clean_area() const {
    return GetField<int64_t>(VT_CLEAN_AREA, 0);
  }
  int64_t map_area() const {
    return GetField<int64_t>(VT_MAP_AREA, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MODE) &&
           VerifyField<int64_t>(verifier, VT_START_TIME) &&
           VerifyField<int64_t>(verifier, VT_STOP_TIME) &&
           VerifyField<int64_t>(verifier, VT_RUN_TIME) &&
           VerifyField<int64_t>(verifier, VT_CLEAN_AREA) &&
           VerifyField<int64_t>(verifier, VT_MAP_AREA) &&
           verifier.EndTable();
  }
};

struct RecordDataBuilder {
  typedef RecordData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(swr::IntelligenceMode mode) {
    fbb_.AddElement<int8_t>(RecordData::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  void add_start_time(int64_t start_time) {
    fbb_.AddElement<int64_t>(RecordData::VT_START_TIME, start_time, 0);
  }
  void add_stop_time(int64_t stop_time) {
    fbb_.AddElement<int64_t>(RecordData::VT_STOP_TIME, stop_time, 0);
  }
  void add_run_time(int64_t run_time) {
    fbb_.AddElement<int64_t>(RecordData::VT_RUN_TIME, run_time, 0);
  }
  void add_clean_area(int64_t clean_area) {
    fbb_.AddElement<int64_t>(RecordData::VT_CLEAN_AREA, clean_area, 0);
  }
  void add_map_area(int64_t map_area) {
    fbb_.AddElement<int64_t>(RecordData::VT_MAP_AREA, map_area, 0);
  }
  explicit RecordDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RecordDataBuilder &operator=(const RecordDataBuilder &);
  flatbuffers::Offset<RecordData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RecordData>(end);
    return o;
  }
};

inline flatbuffers::Offset<RecordData> CreateRecordData(
    flatbuffers::FlatBufferBuilder &_fbb,
    swr::IntelligenceMode mode = swr::IntelligenceMode_Teach,
    int64_t start_time = 0,
    int64_t stop_time = 0,
    int64_t run_time = 0,
    int64_t clean_area = 0,
    int64_t map_area = 0) {
  RecordDataBuilder builder_(_fbb);
  builder_.add_map_area(map_area);
  builder_.add_clean_area(clean_area);
  builder_.add_run_time(run_time);
  builder_.add_stop_time(stop_time);
  builder_.add_start_time(start_time);
  builder_.add_mode(mode);
  return builder_.Finish();
}

struct RouteInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RouteInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXIST_STATUS = 4,
    VT_TRACK_MODE = 6,
    VT_SITE_CODE = 8,
    VT_HLC_CODE = 10,
    VT_SLOT_CODE = 12,
    VT_ROUTE_ID = 14,
    VT_ROUTE_NAME = 16,
    VT_BODY_NUM = 18,
    VT_MACHINE_NAME = 20,
    VT_FILE_SIZE = 22,
    VT_TIME = 24,
    VT_THUMBNAIL_PATH = 26,
    VT_MAP_PATH = 28,
    VT_TRACK_PATH = 30,
    VT_FLOOR_NAME = 32,
    VT_SITE_NAME = 34,
    VT_LOCATION_NAME = 36
  };
  int32_t exist_status() const {
    return GetField<int32_t>(VT_EXIST_STATUS, 0);
  }
  int32_t track_mode() const {
    return GetField<int32_t>(VT_TRACK_MODE, 0);
  }
  const flatbuffers::String *site_code() const {
    return GetPointer<const flatbuffers::String *>(VT_SITE_CODE);
  }
  const flatbuffers::String *hlc_code() const {
    return GetPointer<const flatbuffers::String *>(VT_HLC_CODE);
  }
  uint8_t slot_code() const {
    return GetField<uint8_t>(VT_SLOT_CODE, 0);
  }
  const flatbuffers::String *route_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ROUTE_ID);
  }
  const flatbuffers::String *route_name() const {
    return GetPointer<const flatbuffers::String *>(VT_ROUTE_NAME);
  }
  const flatbuffers::String *body_num() const {
    return GetPointer<const flatbuffers::String *>(VT_BODY_NUM);
  }
  const flatbuffers::String *machine_name() const {
    return GetPointer<const flatbuffers::String *>(VT_MACHINE_NAME);
  }
  int32_t file_size() const {
    return GetField<int32_t>(VT_FILE_SIZE, 0);
  }
  int64_t time() const {
    return GetField<int64_t>(VT_TIME, 0);
  }
  const flatbuffers::String *thumbnail_path() const {
    return GetPointer<const flatbuffers::String *>(VT_THUMBNAIL_PATH);
  }
  const flatbuffers::String *map_path() const {
    return GetPointer<const flatbuffers::String *>(VT_MAP_PATH);
  }
  const flatbuffers::String *track_path() const {
    return GetPointer<const flatbuffers::String *>(VT_TRACK_PATH);
  }
  const flatbuffers::String *floor_name() const {
    return GetPointer<const flatbuffers::String *>(VT_FLOOR_NAME);
  }
  const flatbuffers::String *site_name() const {
    return GetPointer<const flatbuffers::String *>(VT_SITE_NAME);
  }
  const flatbuffers::String *location_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LOCATION_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_EXIST_STATUS) &&
           VerifyField<int32_t>(verifier, VT_TRACK_MODE) &&
           VerifyOffset(verifier, VT_SITE_CODE) &&
           verifier.VerifyString(site_code()) &&
           VerifyOffset(verifier, VT_HLC_CODE) &&
           verifier.VerifyString(hlc_code()) &&
           VerifyField<uint8_t>(verifier, VT_SLOT_CODE) &&
           VerifyOffset(verifier, VT_ROUTE_ID) &&
           verifier.VerifyString(route_id()) &&
           VerifyOffset(verifier, VT_ROUTE_NAME) &&
           verifier.VerifyString(route_name()) &&
           VerifyOffset(verifier, VT_BODY_NUM) &&
           verifier.VerifyString(body_num()) &&
           VerifyOffset(verifier, VT_MACHINE_NAME) &&
           verifier.VerifyString(machine_name()) &&
           VerifyField<int32_t>(verifier, VT_FILE_SIZE) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_THUMBNAIL_PATH) &&
           verifier.VerifyString(thumbnail_path()) &&
           VerifyOffset(verifier, VT_MAP_PATH) &&
           verifier.VerifyString(map_path()) &&
           VerifyOffset(verifier, VT_TRACK_PATH) &&
           verifier.VerifyString(track_path()) &&
           VerifyOffset(verifier, VT_FLOOR_NAME) &&
           verifier.VerifyString(floor_name()) &&
           VerifyOffset(verifier, VT_SITE_NAME) &&
           verifier.VerifyString(site_name()) &&
           VerifyOffset(verifier, VT_LOCATION_NAME) &&
           verifier.VerifyString(location_name()) &&
           verifier.EndTable();
  }
};

struct RouteInfoBuilder {
  typedef RouteInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_exist_status(int32_t exist_status) {
    fbb_.AddElement<int32_t>(RouteInfo::VT_EXIST_STATUS, exist_status, 0);
  }
  void add_track_mode(int32_t track_mode) {
    fbb_.AddElement<int32_t>(RouteInfo::VT_TRACK_MODE, track_mode, 0);
  }
  void add_site_code(flatbuffers::Offset<flatbuffers::String> site_code) {
    fbb_.AddOffset(RouteInfo::VT_SITE_CODE, site_code);
  }
  void add_hlc_code(flatbuffers::Offset<flatbuffers::String> hlc_code) {
    fbb_.AddOffset(RouteInfo::VT_HLC_CODE, hlc_code);
  }
  void add_slot_code(uint8_t slot_code) {
    fbb_.AddElement<uint8_t>(RouteInfo::VT_SLOT_CODE, slot_code, 0);
  }
  void add_route_id(flatbuffers::Offset<flatbuffers::String> route_id) {
    fbb_.AddOffset(RouteInfo::VT_ROUTE_ID, route_id);
  }
  void add_route_name(flatbuffers::Offset<flatbuffers::String> route_name) {
    fbb_.AddOffset(RouteInfo::VT_ROUTE_NAME, route_name);
  }
  void add_body_num(flatbuffers::Offset<flatbuffers::String> body_num) {
    fbb_.AddOffset(RouteInfo::VT_BODY_NUM, body_num);
  }
  void add_machine_name(flatbuffers::Offset<flatbuffers::String> machine_name) {
    fbb_.AddOffset(RouteInfo::VT_MACHINE_NAME, machine_name);
  }
  void add_file_size(int32_t file_size) {
    fbb_.AddElement<int32_t>(RouteInfo::VT_FILE_SIZE, file_size, 0);
  }
  void add_time(int64_t time) {
    fbb_.AddElement<int64_t>(RouteInfo::VT_TIME, time, 0);
  }
  void add_thumbnail_path(flatbuffers::Offset<flatbuffers::String> thumbnail_path) {
    fbb_.AddOffset(RouteInfo::VT_THUMBNAIL_PATH, thumbnail_path);
  }
  void add_map_path(flatbuffers::Offset<flatbuffers::String> map_path) {
    fbb_.AddOffset(RouteInfo::VT_MAP_PATH, map_path);
  }
  void add_track_path(flatbuffers::Offset<flatbuffers::String> track_path) {
    fbb_.AddOffset(RouteInfo::VT_TRACK_PATH, track_path);
  }
  void add_floor_name(flatbuffers::Offset<flatbuffers::String> floor_name) {
    fbb_.AddOffset(RouteInfo::VT_FLOOR_NAME, floor_name);
  }
  void add_site_name(flatbuffers::Offset<flatbuffers::String> site_name) {
    fbb_.AddOffset(RouteInfo::VT_SITE_NAME, site_name);
  }
  void add_location_name(flatbuffers::Offset<flatbuffers::String> location_name) {
    fbb_.AddOffset(RouteInfo::VT_LOCATION_NAME, location_name);
  }
  explicit RouteInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RouteInfoBuilder &operator=(const RouteInfoBuilder &);
  flatbuffers::Offset<RouteInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RouteInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<RouteInfo> CreateRouteInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t exist_status = 0,
    int32_t track_mode = 0,
    flatbuffers::Offset<flatbuffers::String> site_code = 0,
    flatbuffers::Offset<flatbuffers::String> hlc_code = 0,
    uint8_t slot_code = 0,
    flatbuffers::Offset<flatbuffers::String> route_id = 0,
    flatbuffers::Offset<flatbuffers::String> route_name = 0,
    flatbuffers::Offset<flatbuffers::String> body_num = 0,
    flatbuffers::Offset<flatbuffers::String> machine_name = 0,
    int32_t file_size = 0,
    int64_t time = 0,
    flatbuffers::Offset<flatbuffers::String> thumbnail_path = 0,
    flatbuffers::Offset<flatbuffers::String> map_path = 0,
    flatbuffers::Offset<flatbuffers::String> track_path = 0,
    flatbuffers::Offset<flatbuffers::String> floor_name = 0,
    flatbuffers::Offset<flatbuffers::String> site_name = 0,
    flatbuffers::Offset<flatbuffers::String> location_name = 0) {
  RouteInfoBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_location_name(location_name);
  builder_.add_site_name(site_name);
  builder_.add_floor_name(floor_name);
  builder_.add_track_path(track_path);
  builder_.add_map_path(map_path);
  builder_.add_thumbnail_path(thumbnail_path);
  builder_.add_file_size(file_size);
  builder_.add_machine_name(machine_name);
  builder_.add_body_num(body_num);
  builder_.add_route_name(route_name);
  builder_.add_route_id(route_id);
  builder_.add_hlc_code(hlc_code);
  builder_.add_site_code(site_code);
  builder_.add_track_mode(track_mode);
  builder_.add_exist_status(exist_status);
  builder_.add_slot_code(slot_code);
  return builder_.Finish();
}

inline flatbuffers::Offset<RouteInfo> CreateRouteInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t exist_status = 0,
    int32_t track_mode = 0,
    const char *site_code = nullptr,
    const char *hlc_code = nullptr,
    uint8_t slot_code = 0,
    const char *route_id = nullptr,
    const char *route_name = nullptr,
    const char *body_num = nullptr,
    const char *machine_name = nullptr,
    int32_t file_size = 0,
    int64_t time = 0,
    const char *thumbnail_path = nullptr,
    const char *map_path = nullptr,
    const char *track_path = nullptr,
    const char *floor_name = nullptr,
    const char *site_name = nullptr,
    const char *location_name = nullptr) {
  auto site_code__ = site_code ? _fbb.CreateString(site_code) : 0;
  auto hlc_code__ = hlc_code ? _fbb.CreateString(hlc_code) : 0;
  auto route_id__ = route_id ? _fbb.CreateString(route_id) : 0;
  auto route_name__ = route_name ? _fbb.CreateString(route_name) : 0;
  auto body_num__ = body_num ? _fbb.CreateString(body_num) : 0;
  auto machine_name__ = machine_name ? _fbb.CreateString(machine_name) : 0;
  auto thumbnail_path__ = thumbnail_path ? _fbb.CreateString(thumbnail_path) : 0;
  auto map_path__ = map_path ? _fbb.CreateString(map_path) : 0;
  auto track_path__ = track_path ? _fbb.CreateString(track_path) : 0;
  auto floor_name__ = floor_name ? _fbb.CreateString(floor_name) : 0;
  auto site_name__ = site_name ? _fbb.CreateString(site_name) : 0;
  auto location_name__ = location_name ? _fbb.CreateString(location_name) : 0;
  return swr::CreateRouteInfo(
      _fbb,
      exist_status,
      track_mode,
      site_code__,
      hlc_code__,
      slot_code,
      route_id__,
      route_name__,
      body_num__,
      machine_name__,
      file_size,
      time,
      thumbnail_path__,
      map_path__,
      track_path__,
      floor_name__,
      site_name__,
      location_name__);
}

struct HoursData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HoursDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOTAL_TEACHING_TIME = 4,
    VT_TOTAL_MANUAL_TIME = 6,
    VT_TOTAL_DURATION_AUTONOMY = 8
  };
  uint32_t total_teaching_time() const {
    return GetField<uint32_t>(VT_TOTAL_TEACHING_TIME, 0);
  }
  uint32_t total_manual_time() const {
    return GetField<uint32_t>(VT_TOTAL_MANUAL_TIME, 0);
  }
  uint32_t total_duration_autonomy() const {
    return GetField<uint32_t>(VT_TOTAL_DURATION_AUTONOMY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TOTAL_TEACHING_TIME) &&
           VerifyField<uint32_t>(verifier, VT_TOTAL_MANUAL_TIME) &&
           VerifyField<uint32_t>(verifier, VT_TOTAL_DURATION_AUTONOMY) &&
           verifier.EndTable();
  }
};

struct HoursDataBuilder {
  typedef HoursData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_total_teaching_time(uint32_t total_teaching_time) {
    fbb_.AddElement<uint32_t>(HoursData::VT_TOTAL_TEACHING_TIME, total_teaching_time, 0);
  }
  void add_total_manual_time(uint32_t total_manual_time) {
    fbb_.AddElement<uint32_t>(HoursData::VT_TOTAL_MANUAL_TIME, total_manual_time, 0);
  }
  void add_total_duration_autonomy(uint32_t total_duration_autonomy) {
    fbb_.AddElement<uint32_t>(HoursData::VT_TOTAL_DURATION_AUTONOMY, total_duration_autonomy, 0);
  }
  explicit HoursDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HoursDataBuilder &operator=(const HoursDataBuilder &);
  flatbuffers::Offset<HoursData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HoursData>(end);
    return o;
  }
};

inline flatbuffers::Offset<HoursData> CreateHoursData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t total_teaching_time = 0,
    uint32_t total_manual_time = 0,
    uint32_t total_duration_autonomy = 0) {
  HoursDataBuilder builder_(_fbb);
  builder_.add_total_duration_autonomy(total_duration_autonomy);
  builder_.add_total_manual_time(total_manual_time);
  builder_.add_total_teaching_time(total_teaching_time);
  return builder_.Finish();
}

struct WorkLog FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WorkLogBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SITE_CODE = 4,
    VT_HLC_ID = 6,
    VT_SLOT_CODE = 8,
    VT_ROUTE_ID = 10,
    VT_START_TIME = 12,
    VT_END_TIME = 14,
    VT_USAGE_TIME = 16,
    VT_CODE_LENGTH = 18,
    VT_RUN_LENGTH = 20,
    VT_CLEANED_AREA = 22,
    VT_DEDUP_CLEAN_AREA = 24,
    VT_AVG_SPEED = 26,
    VT_ASSIST_COUNT = 28,
    VT_ROUTE_CODE = 30,
    VT_BOOT_CARD_NUM = 32,
    VT_ICON_CODE = 34,
    VT_WORK_CLASS = 36,
    VT_WORK_TIME = 38
  };
  const flatbuffers::String *site_code() const {
    return GetPointer<const flatbuffers::String *>(VT_SITE_CODE);
  }
  int32_t hlc_id() const {
    return GetField<int32_t>(VT_HLC_ID, 0);
  }
  int8_t slot_code() const {
    return GetField<int8_t>(VT_SLOT_CODE, 0);
  }
  const flatbuffers::String *route_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ROUTE_ID);
  }
  int32_t start_time() const {
    return GetField<int32_t>(VT_START_TIME, 0);
  }
  int32_t end_time() const {
    return GetField<int32_t>(VT_END_TIME, 0);
  }
  int32_t usage_time() const {
    return GetField<int32_t>(VT_USAGE_TIME, 0);
  }
  int32_t code_length() const {
    return GetField<int32_t>(VT_CODE_LENGTH, 0);
  }
  int32_t run_length() const {
    return GetField<int32_t>(VT_RUN_LENGTH, 0);
  }
  int32_t cleaned_area() const {
    return GetField<int32_t>(VT_CLEANED_AREA, 0);
  }
  int32_t dedup_clean_area() const {
    return GetField<int32_t>(VT_DEDUP_CLEAN_AREA, 0);
  }
  int32_t avg_speed() const {
    return GetField<int32_t>(VT_AVG_SPEED, 0);
  }
  int32_t assist_count() const {
    return GetField<int32_t>(VT_ASSIST_COUNT, 0);
  }
  const flatbuffers::String *route_code() const {
    return GetPointer<const flatbuffers::String *>(VT_ROUTE_CODE);
  }
  int32_t boot_card_num() const {
    return GetField<int32_t>(VT_BOOT_CARD_NUM, 0);
  }
  const flatbuffers::String *icon_code() const {
    return GetPointer<const flatbuffers::String *>(VT_ICON_CODE);
  }
  swr::WorkClass work_class() const {
    return static_cast<swr::WorkClass>(GetField<int8_t>(VT_WORK_CLASS, 0));
  }
  int32_t work_time() const {
    return GetField<int32_t>(VT_WORK_TIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SITE_CODE) &&
           verifier.VerifyString(site_code()) &&
           VerifyField<int32_t>(verifier, VT_HLC_ID) &&
           VerifyField<int8_t>(verifier, VT_SLOT_CODE) &&
           VerifyOffset(verifier, VT_ROUTE_ID) &&
           verifier.VerifyString(route_id()) &&
           VerifyField<int32_t>(verifier, VT_START_TIME) &&
           VerifyField<int32_t>(verifier, VT_END_TIME) &&
           VerifyField<int32_t>(verifier, VT_USAGE_TIME) &&
           VerifyField<int32_t>(verifier, VT_CODE_LENGTH) &&
           VerifyField<int32_t>(verifier, VT_RUN_LENGTH) &&
           VerifyField<int32_t>(verifier, VT_CLEANED_AREA) &&
           VerifyField<int32_t>(verifier, VT_DEDUP_CLEAN_AREA) &&
           VerifyField<int32_t>(verifier, VT_AVG_SPEED) &&
           VerifyField<int32_t>(verifier, VT_ASSIST_COUNT) &&
           VerifyOffset(verifier, VT_ROUTE_CODE) &&
           verifier.VerifyString(route_code()) &&
           VerifyField<int32_t>(verifier, VT_BOOT_CARD_NUM) &&
           VerifyOffset(verifier, VT_ICON_CODE) &&
           verifier.VerifyString(icon_code()) &&
           VerifyField<int8_t>(verifier, VT_WORK_CLASS) &&
           VerifyField<int32_t>(verifier, VT_WORK_TIME) &&
           verifier.EndTable();
  }
};

struct WorkLogBuilder {
  typedef WorkLog Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_site_code(flatbuffers::Offset<flatbuffers::String> site_code) {
    fbb_.AddOffset(WorkLog::VT_SITE_CODE, site_code);
  }
  void add_hlc_id(int32_t hlc_id) {
    fbb_.AddElement<int32_t>(WorkLog::VT_HLC_ID, hlc_id, 0);
  }
  void add_slot_code(int8_t slot_code) {
    fbb_.AddElement<int8_t>(WorkLog::VT_SLOT_CODE, slot_code, 0);
  }
  void add_route_id(flatbuffers::Offset<flatbuffers::String> route_id) {
    fbb_.AddOffset(WorkLog::VT_ROUTE_ID, route_id);
  }
  void add_start_time(int32_t start_time) {
    fbb_.AddElement<int32_t>(WorkLog::VT_START_TIME, start_time, 0);
  }
  void add_end_time(int32_t end_time) {
    fbb_.AddElement<int32_t>(WorkLog::VT_END_TIME, end_time, 0);
  }
  void add_usage_time(int32_t usage_time) {
    fbb_.AddElement<int32_t>(WorkLog::VT_USAGE_TIME, usage_time, 0);
  }
  void add_code_length(int32_t code_length) {
    fbb_.AddElement<int32_t>(WorkLog::VT_CODE_LENGTH, code_length, 0);
  }
  void add_run_length(int32_t run_length) {
    fbb_.AddElement<int32_t>(WorkLog::VT_RUN_LENGTH, run_length, 0);
  }
  void add_cleaned_area(int32_t cleaned_area) {
    fbb_.AddElement<int32_t>(WorkLog::VT_CLEANED_AREA, cleaned_area, 0);
  }
  void add_dedup_clean_area(int32_t dedup_clean_area) {
    fbb_.AddElement<int32_t>(WorkLog::VT_DEDUP_CLEAN_AREA, dedup_clean_area, 0);
  }
  void add_avg_speed(int32_t avg_speed) {
    fbb_.AddElement<int32_t>(WorkLog::VT_AVG_SPEED, avg_speed, 0);
  }
  void add_assist_count(int32_t assist_count) {
    fbb_.AddElement<int32_t>(WorkLog::VT_ASSIST_COUNT, assist_count, 0);
  }
  void add_route_code(flatbuffers::Offset<flatbuffers::String> route_code) {
    fbb_.AddOffset(WorkLog::VT_ROUTE_CODE, route_code);
  }
  void add_boot_card_num(int32_t boot_card_num) {
    fbb_.AddElement<int32_t>(WorkLog::VT_BOOT_CARD_NUM, boot_card_num, 0);
  }
  void add_icon_code(flatbuffers::Offset<flatbuffers::String> icon_code) {
    fbb_.AddOffset(WorkLog::VT_ICON_CODE, icon_code);
  }
  void add_work_class(swr::WorkClass work_class) {
    fbb_.AddElement<int8_t>(WorkLog::VT_WORK_CLASS, static_cast<int8_t>(work_class), 0);
  }
  void add_work_time(int32_t work_time) {
    fbb_.AddElement<int32_t>(WorkLog::VT_WORK_TIME, work_time, 0);
  }
  explicit WorkLogBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WorkLogBuilder &operator=(const WorkLogBuilder &);
  flatbuffers::Offset<WorkLog> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WorkLog>(end);
    return o;
  }
};

inline flatbuffers::Offset<WorkLog> CreateWorkLog(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> site_code = 0,
    int32_t hlc_id = 0,
    int8_t slot_code = 0,
    flatbuffers::Offset<flatbuffers::String> route_id = 0,
    int32_t start_time = 0,
    int32_t end_time = 0,
    int32_t usage_time = 0,
    int32_t code_length = 0,
    int32_t run_length = 0,
    int32_t cleaned_area = 0,
    int32_t dedup_clean_area = 0,
    int32_t avg_speed = 0,
    int32_t assist_count = 0,
    flatbuffers::Offset<flatbuffers::String> route_code = 0,
    int32_t boot_card_num = 0,
    flatbuffers::Offset<flatbuffers::String> icon_code = 0,
    swr::WorkClass work_class = swr::WorkClass_Default,
    int32_t work_time = 0) {
  WorkLogBuilder builder_(_fbb);
  builder_.add_work_time(work_time);
  builder_.add_icon_code(icon_code);
  builder_.add_boot_card_num(boot_card_num);
  builder_.add_route_code(route_code);
  builder_.add_assist_count(assist_count);
  builder_.add_avg_speed(avg_speed);
  builder_.add_dedup_clean_area(dedup_clean_area);
  builder_.add_cleaned_area(cleaned_area);
  builder_.add_run_length(run_length);
  builder_.add_code_length(code_length);
  builder_.add_usage_time(usage_time);
  builder_.add_end_time(end_time);
  builder_.add_start_time(start_time);
  builder_.add_route_id(route_id);
  builder_.add_hlc_id(hlc_id);
  builder_.add_site_code(site_code);
  builder_.add_work_class(work_class);
  builder_.add_slot_code(slot_code);
  return builder_.Finish();
}

inline flatbuffers::Offset<WorkLog> CreateWorkLogDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *site_code = nullptr,
    int32_t hlc_id = 0,
    int8_t slot_code = 0,
    const char *route_id = nullptr,
    int32_t start_time = 0,
    int32_t end_time = 0,
    int32_t usage_time = 0,
    int32_t code_length = 0,
    int32_t run_length = 0,
    int32_t cleaned_area = 0,
    int32_t dedup_clean_area = 0,
    int32_t avg_speed = 0,
    int32_t assist_count = 0,
    const char *route_code = nullptr,
    int32_t boot_card_num = 0,
    const char *icon_code = nullptr,
    swr::WorkClass work_class = swr::WorkClass_Default,
    int32_t work_time = 0) {
  auto site_code__ = site_code ? _fbb.CreateString(site_code) : 0;
  auto route_id__ = route_id ? _fbb.CreateString(route_id) : 0;
  auto route_code__ = route_code ? _fbb.CreateString(route_code) : 0;
  auto icon_code__ = icon_code ? _fbb.CreateString(icon_code) : 0;
  return swr::CreateWorkLog(
      _fbb,
      site_code__,
      hlc_id,
      slot_code,
      route_id__,
      start_time,
      end_time,
      usage_time,
      code_length,
      run_length,
      cleaned_area,
      dedup_clean_area,
      avg_speed,
      assist_count,
      route_code__,
      boot_card_num,
      icon_code__,
      work_class,
      work_time);
}

struct LoginUser FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LoginUserBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_NAME = 6,
    VT_PWD = 8
  };
  swr::UserType type() const {
    return static_cast<swr::UserType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *pwd() const {
    return GetPointer<const flatbuffers::String *>(VT_PWD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_PWD) &&
           verifier.VerifyString(pwd()) &&
           verifier.EndTable();
  }
};

struct LoginUserBuilder {
  typedef LoginUser Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(swr::UserType type) {
    fbb_.AddElement<int8_t>(LoginUser::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(LoginUser::VT_NAME, name);
  }
  void add_pwd(flatbuffers::Offset<flatbuffers::String> pwd) {
    fbb_.AddOffset(LoginUser::VT_PWD, pwd);
  }
  explicit LoginUserBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LoginUserBuilder &operator=(const LoginUserBuilder &);
  flatbuffers::Offset<LoginUser> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LoginUser>(end);
    return o;
  }
};

inline flatbuffers::Offset<LoginUser> CreateLoginUser(
    flatbuffers::FlatBufferBuilder &_fbb,
    swr::UserType type = swr::UserType_CustomerManagement,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> pwd = 0) {
  LoginUserBuilder builder_(_fbb);
  builder_.add_pwd(pwd);
  builder_.add_name(name);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<LoginUser> CreateLoginUserDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    swr::UserType type = swr::UserType_CustomerManagement,
    const char *name = nullptr,
    const char *pwd = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto pwd__ = pwd ? _fbb.CreateString(pwd) : 0;
  return swr::CreateLoginUser(
      _fbb,
      type,
      name__,
      pwd__);
}

struct Public FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PublicBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PublicBuilder {
  typedef Public Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PublicBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PublicBuilder &operator=(const PublicBuilder &);
  flatbuffers::Offset<Public> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Public>(end);
    return o;
  }
};

inline flatbuffers::Offset<Public> CreatePublic(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PublicBuilder builder_(_fbb);
  return builder_.Finish();
}

inline bool VerifyEquipmentUnitData(flatbuffers::Verifier &verifier, const void *obj, EquipmentUnitData type) {
  switch (type) {
    case EquipmentUnitData_NONE: {
      return true;
    }
    case EquipmentUnitData_CoreUnit: {
      auto ptr = reinterpret_cast<const swr::CoreUnit *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EquipmentUnitData_MotorUnit: {
      auto ptr = reinterpret_cast<const swr::MotorUnit *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EquipmentUnitData_SensorUnit: {
      auto ptr = reinterpret_cast<const swr::SensorUnit *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EquipmentUnitData_OtherUnit: {
      auto ptr = reinterpret_cast<const swr::OtherUnit *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyEquipmentUnitDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyEquipmentUnitData(
        verifier,  values->Get(i), types->GetEnum<EquipmentUnitData>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyMachineParamData(flatbuffers::Verifier &verifier, const void *obj, MachineParamData type) {
  switch (type) {
    case MachineParamData_NONE: {
      return true;
    }
    case MachineParamData_WalkingMotorParams: {
      auto ptr = reinterpret_cast<const swr::WalkingMotorParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MachineParamData_LeftAndRightBrushMotorParams: {
      auto ptr = reinterpret_cast<const swr::LeftAndRightBrushMotorParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MachineParamData_MainBrushMotorParams: {
      auto ptr = reinterpret_cast<const swr::MainBrushMotorParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MachineParamData_BrushWirePusherParams: {
      auto ptr = reinterpret_cast<const swr::BrushWirePusherParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MachineParamData_WaterHangingWirePusherParams: {
      auto ptr = reinterpret_cast<const swr::WaterHangingWirePusherParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MachineParamData_SuctionPumpParams: {
      auto ptr = reinterpret_cast<const swr::SuctionPumpParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MachineParamData_CleanWaterPumpParams: {
      auto ptr = reinterpret_cast<const swr::CleanWaterPumpParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MachineParamData_BatteryParams: {
      auto ptr = reinterpret_cast<const swr::BatteryParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMachineParamDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMachineParamData(
        verifier,  values->Get(i), types->GetEnum<MachineParamData>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyTestingItemData(flatbuffers::Verifier &verifier, const void *obj, TestingItemData type) {
  switch (type) {
    case TestingItemData_NONE: {
      return true;
    }
    case TestingItemData_Switch: {
      auto ptr = reinterpret_cast<const swr::Switch *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case TestingItemData_WirePusher: {
      auto ptr = reinterpret_cast<const swr::WirePusher *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case TestingItemData_WaterPumpGear: {
      auto ptr = reinterpret_cast<const swr::WaterPumpGear *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case TestingItemData_Brake: {
      auto ptr = reinterpret_cast<const swr::Brake *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case TestingItemData_LightBelt: {
      auto ptr = reinterpret_cast<const swr::LightBelt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTestingItemDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyTestingItemData(
        verifier,  values->Get(i), types->GetEnum<TestingItemData>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyFaultSettingRqst(flatbuffers::Verifier &verifier, const void *obj, FaultSettingRqst type) {
  switch (type) {
    case FaultSettingRqst_NONE: {
      return true;
    }
    case FaultSettingRqst_Switch: {
      auto ptr = reinterpret_cast<const swr::Switch *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case FaultSettingRqst_FaultSettingData: {
      auto ptr = reinterpret_cast<const swr::FaultSettingData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyFaultSettingRqstVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyFaultSettingRqst(
        verifier,  values->Get(i), types->GetEnum<FaultSettingRqst>(i))) {
      return false;
    }
  }
  return true;
}

inline const swr::Public *GetPublic(const void *buf) {
  return flatbuffers::GetRoot<swr::Public>(buf);
}

inline const swr::Public *GetSizePrefixedPublic(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<swr::Public>(buf);
}

inline bool VerifyPublicBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<swr::Public>(nullptr);
}

inline bool VerifySizePrefixedPublicBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<swr::Public>(nullptr);
}

inline void FinishPublicBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<swr::Public> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPublicBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<swr::Public> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace swr

#endif  // FLATBUFFERS_GENERATED_PUBLIC_SWR_H_
