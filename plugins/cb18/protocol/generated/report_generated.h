// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_REPORT_SWR_H_
#define FLATBUFFERS_GENERATED_REPORT_SWR_H_

#include "flatbuffers/flatbuffers.h"

#include "public_generated.h"

namespace swr {

struct ReportBlueTrigger;
struct ReportBlueTriggerBuilder;

struct ReportSelfTestProcess;
struct ReportSelfTestProcessBuilder;

struct ReportSelfTest;
struct ReportSelfTestBuilder;

struct ReportImage;
struct ReportImageBuilder;

struct ReportRosMap;
struct ReportRosMapBuilder;

struct ReportPose;
struct ReportPoseBuilder;

struct ReportCleanTime;
struct ReportCleanTimeBuilder;

struct ReportCleanArea;
struct ReportCleanAreaBuilder;

struct ReportAutoClean;
struct ReportAutoCleanBuilder;

struct ReportCloudState;
struct ReportCloudStateBuilder;

struct ReportNetLevel;
struct ReportNetLevelBuilder;

struct ReportBatteryLevel;
struct ReportBatteryLevelBuilder;

struct ReportTitleBar;
struct ReportTitleBarBuilder;

struct ReportDistinguishRLT;
struct ReportDistinguishRLTBuilder;

struct ReportCalculateRLT;
struct ReportCalculateRLTBuilder;

struct ReportScanQR;
struct ReportScanQRBuilder;

struct ReportSiteInfo;
struct ReportSiteInfoBuilder;

struct ReportRouteInfo;
struct ReportRouteInfoBuilder;

struct ReportDownloadProgress;
struct ReportDownloadProgressBuilder;

struct ReportTestRealTimeStatus;
struct ReportTestRealTimeStatusBuilder;

struct ReportPerson;
struct ReportPersonBuilder;

struct ReportElevator;
struct ReportElevatorBuilder;

struct ReportPowerDown;
struct ReportPowerDownBuilder;

struct ReportOrientedPoint;
struct ReportOrientedPointBuilder;

struct ReportFaultCode;
struct ReportFaultCodeBuilder;

struct ReportLockFaultCode;
struct ReportLockFaultCodeBuilder;

struct ReportRobotEvent;
struct ReportRobotEventBuilder;

struct ReportSlamMapSendCompleted;
struct ReportSlamMapSendCompletedBuilder;

struct Report;
struct ReportBuilder;

enum ReportTitleBarType {
  ReportTitleBarType_ReportCloudState = 0,
  ReportTitleBarType_ReportNetLevel = 1,
  ReportTitleBarType_ReportBatteryLevel = 2,
  ReportTitleBarType_MIN = ReportTitleBarType_ReportCloudState,
  ReportTitleBarType_MAX = ReportTitleBarType_ReportBatteryLevel
};

inline const ReportTitleBarType (&EnumValuesReportTitleBarType())[3] {
  static const ReportTitleBarType values[] = {
    ReportTitleBarType_ReportCloudState,
    ReportTitleBarType_ReportNetLevel,
    ReportTitleBarType_ReportBatteryLevel
  };
  return values;
}

inline const char * const *EnumNamesReportTitleBarType() {
  static const char * const names[4] = {
    "ReportCloudState",
    "ReportNetLevel",
    "ReportBatteryLevel",
    nullptr
  };
  return names;
}

inline const char *EnumNameReportTitleBarType(ReportTitleBarType e) {
  if (flatbuffers::IsOutRange(e, ReportTitleBarType_ReportCloudState, ReportTitleBarType_ReportBatteryLevel)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReportTitleBarType()[index];
}

enum ReportTitleBarData {
  ReportTitleBarData_NONE = 0,
  ReportTitleBarData_ReportCloudState = 1,
  ReportTitleBarData_ReportNetLevel = 2,
  ReportTitleBarData_ReportBatteryLevel = 3,
  ReportTitleBarData_MIN = ReportTitleBarData_NONE,
  ReportTitleBarData_MAX = ReportTitleBarData_ReportBatteryLevel
};

inline const ReportTitleBarData (&EnumValuesReportTitleBarData())[4] {
  static const ReportTitleBarData values[] = {
    ReportTitleBarData_NONE,
    ReportTitleBarData_ReportCloudState,
    ReportTitleBarData_ReportNetLevel,
    ReportTitleBarData_ReportBatteryLevel
  };
  return values;
}

inline const char * const *EnumNamesReportTitleBarData() {
  static const char * const names[5] = {
    "NONE",
    "ReportCloudState",
    "ReportNetLevel",
    "ReportBatteryLevel",
    nullptr
  };
  return names;
}

inline const char *EnumNameReportTitleBarData(ReportTitleBarData e) {
  if (flatbuffers::IsOutRange(e, ReportTitleBarData_NONE, ReportTitleBarData_ReportBatteryLevel)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReportTitleBarData()[index];
}

template<typename T> struct ReportTitleBarDataTraits {
  static const ReportTitleBarData enum_value = ReportTitleBarData_NONE;
};

template<> struct ReportTitleBarDataTraits<swr::ReportCloudState> {
  static const ReportTitleBarData enum_value = ReportTitleBarData_ReportCloudState;
};

template<> struct ReportTitleBarDataTraits<swr::ReportNetLevel> {
  static const ReportTitleBarData enum_value = ReportTitleBarData_ReportNetLevel;
};

template<> struct ReportTitleBarDataTraits<swr::ReportBatteryLevel> {
  static const ReportTitleBarData enum_value = ReportTitleBarData_ReportBatteryLevel;
};

bool VerifyReportTitleBarData(flatbuffers::Verifier &verifier, const void *obj, ReportTitleBarData type);
bool VerifyReportTitleBarDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum ReprotMarkerType {
  ReprotMarkerType_MarkerTypeDistinguish = 0,
  ReprotMarkerType_MarkerTypeCalculate = 1,
  ReprotMarkerType_MIN = ReprotMarkerType_MarkerTypeDistinguish,
  ReprotMarkerType_MAX = ReprotMarkerType_MarkerTypeCalculate
};

inline const ReprotMarkerType (&EnumValuesReprotMarkerType())[2] {
  static const ReprotMarkerType values[] = {
    ReprotMarkerType_MarkerTypeDistinguish,
    ReprotMarkerType_MarkerTypeCalculate
  };
  return values;
}

inline const char * const *EnumNamesReprotMarkerType() {
  static const char * const names[3] = {
    "MarkerTypeDistinguish",
    "MarkerTypeCalculate",
    nullptr
  };
  return names;
}

inline const char *EnumNameReprotMarkerType(ReprotMarkerType e) {
  if (flatbuffers::IsOutRange(e, ReprotMarkerType_MarkerTypeDistinguish, ReprotMarkerType_MarkerTypeCalculate)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReprotMarkerType()[index];
}

enum ReportMarkerRLT {
  ReportMarkerRLT_NONE = 0,
  ReportMarkerRLT_ReportDistinguishRLT = 1,
  ReportMarkerRLT_ReportCalculateRLT = 2,
  ReportMarkerRLT_MIN = ReportMarkerRLT_NONE,
  ReportMarkerRLT_MAX = ReportMarkerRLT_ReportCalculateRLT
};

inline const ReportMarkerRLT (&EnumValuesReportMarkerRLT())[3] {
  static const ReportMarkerRLT values[] = {
    ReportMarkerRLT_NONE,
    ReportMarkerRLT_ReportDistinguishRLT,
    ReportMarkerRLT_ReportCalculateRLT
  };
  return values;
}

inline const char * const *EnumNamesReportMarkerRLT() {
  static const char * const names[4] = {
    "NONE",
    "ReportDistinguishRLT",
    "ReportCalculateRLT",
    nullptr
  };
  return names;
}

inline const char *EnumNameReportMarkerRLT(ReportMarkerRLT e) {
  if (flatbuffers::IsOutRange(e, ReportMarkerRLT_NONE, ReportMarkerRLT_ReportCalculateRLT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReportMarkerRLT()[index];
}

template<typename T> struct ReportMarkerRLTTraits {
  static const ReportMarkerRLT enum_value = ReportMarkerRLT_NONE;
};

template<> struct ReportMarkerRLTTraits<swr::ReportDistinguishRLT> {
  static const ReportMarkerRLT enum_value = ReportMarkerRLT_ReportDistinguishRLT;
};

template<> struct ReportMarkerRLTTraits<swr::ReportCalculateRLT> {
  static const ReportMarkerRLT enum_value = ReportMarkerRLT_ReportCalculateRLT;
};

bool VerifyReportMarkerRLT(flatbuffers::Verifier &verifier, const void *obj, ReportMarkerRLT type);
bool VerifyReportMarkerRLTVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum DownloadDataType {
  DownloadDataType_Invalid = 0,
  DownloadDataType_Thumbnail = 1,
  DownloadDataType_Map = 2,
  DownloadDataType_Track = 3,
  DownloadDataType_All = 4,
  DownloadDataType_MIN = DownloadDataType_Invalid,
  DownloadDataType_MAX = DownloadDataType_All
};

inline const DownloadDataType (&EnumValuesDownloadDataType())[5] {
  static const DownloadDataType values[] = {
    DownloadDataType_Invalid,
    DownloadDataType_Thumbnail,
    DownloadDataType_Map,
    DownloadDataType_Track,
    DownloadDataType_All
  };
  return values;
}

inline const char * const *EnumNamesDownloadDataType() {
  static const char * const names[6] = {
    "Invalid",
    "Thumbnail",
    "Map",
    "Track",
    "All",
    nullptr
  };
  return names;
}

inline const char *EnumNameDownloadDataType(DownloadDataType e) {
  if (flatbuffers::IsOutRange(e, DownloadDataType_Invalid, DownloadDataType_All)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDownloadDataType()[index];
}

///////////////////////////////////////////
///////////////////////////////////////////
enum ReportType {
  ReportType_ReportBlueTrigger = 0,
  ReportType_ReportSelfTest = 1,
  ReportType_ReportSelfTestProcess = 2,
  ReportType_ReportImage = 3,
  ReportType_ReportRosMap = 4,
  ReportType_ReportPose = 5,
  ReportType_ReportCleanTime = 6,
  ReportType_ReportCleanArea = 7,
  ReportType_ReportAutoClean = 8,
  ReportType_ReportTitleBar = 9,
  ReportType_ReportScanQR = 10,
  ReportType_ReportSiteInfo = 11,
  ReportType_ReportRouteInfo = 12,
  ReportType_ReportDownloadProgress = 13,
  ReportType_ReportTestRealTimeStatus = 14,
  ReportType_ReportError = 15,
  ReportType_ReportPerson = 16,
  ReportType_ReportElevator = 17,
  ReportType_ReportPowerDown = 18,
  ReportType_ReportOrientedPoint = 19,
  ReportType_ReportFaultCode = 20,
  ReportType_ReportRobotEvent = 21,
  ReportType_ReportSlamMapSendCompleted = 22,
  ReportType_ReportLockFaultCode = 23,
  ReportType_MIN = ReportType_ReportBlueTrigger,
  ReportType_MAX = ReportType_ReportLockFaultCode
};

inline const ReportType (&EnumValuesReportType())[24] {
  static const ReportType values[] = {
    ReportType_ReportBlueTrigger,
    ReportType_ReportSelfTest,
    ReportType_ReportSelfTestProcess,
    ReportType_ReportImage,
    ReportType_ReportRosMap,
    ReportType_ReportPose,
    ReportType_ReportCleanTime,
    ReportType_ReportCleanArea,
    ReportType_ReportAutoClean,
    ReportType_ReportTitleBar,
    ReportType_ReportScanQR,
    ReportType_ReportSiteInfo,
    ReportType_ReportRouteInfo,
    ReportType_ReportDownloadProgress,
    ReportType_ReportTestRealTimeStatus,
    ReportType_ReportError,
    ReportType_ReportPerson,
    ReportType_ReportElevator,
    ReportType_ReportPowerDown,
    ReportType_ReportOrientedPoint,
    ReportType_ReportFaultCode,
    ReportType_ReportRobotEvent,
    ReportType_ReportSlamMapSendCompleted,
    ReportType_ReportLockFaultCode
  };
  return values;
}

inline const char * const *EnumNamesReportType() {
  static const char * const names[25] = {
    "ReportBlueTrigger",
    "ReportSelfTest",
    "ReportSelfTestProcess",
    "ReportImage",
    "ReportRosMap",
    "ReportPose",
    "ReportCleanTime",
    "ReportCleanArea",
    "ReportAutoClean",
    "ReportTitleBar",
    "ReportScanQR",
    "ReportSiteInfo",
    "ReportRouteInfo",
    "ReportDownloadProgress",
    "ReportTestRealTimeStatus",
    "ReportError",
    "ReportPerson",
    "ReportElevator",
    "ReportPowerDown",
    "ReportOrientedPoint",
    "ReportFaultCode",
    "ReportRobotEvent",
    "ReportSlamMapSendCompleted",
    "ReportLockFaultCode",
    nullptr
  };
  return names;
}

inline const char *EnumNameReportType(ReportType e) {
  if (flatbuffers::IsOutRange(e, ReportType_ReportBlueTrigger, ReportType_ReportLockFaultCode)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReportType()[index];
}

///////////////////////////////////////////
///////////////////////////////////////////
enum ReportDataField {
  ReportDataField_NONE = 0,
  ReportDataField_ReportBlueTrigger = 1,
  ReportDataField_ReportSelfTest = 2,
  ReportDataField_ReportSelfTestProcess = 3,
  ReportDataField_ReportImage = 4,
  ReportDataField_ReportRosMap = 5,
  ReportDataField_ReportPose = 6,
  ReportDataField_ReportCleanTime = 7,
  ReportDataField_ReportCleanArea = 8,
  ReportDataField_ReportAutoClean = 9,
  ReportDataField_ReportTitleBar = 10,
  ReportDataField_ReportScanQR = 11,
  ReportDataField_ReportSiteInfo = 12,
  ReportDataField_ReportRouteInfo = 13,
  ReportDataField_ReportDownloadProgress = 14,
  ReportDataField_ReportTestRealTimeStatus = 15,
  ReportDataField_ErrorCode = 16,
  ReportDataField_ReportPerson = 17,
  ReportDataField_ReportElevator = 18,
  ReportDataField_ReportPowerDown = 19,
  ReportDataField_ReportOrientedPoint = 20,
  ReportDataField_ReportFaultCode = 21,
  ReportDataField_ReportRobotEvent = 22,
  ReportDataField_ReportSlamMapSendCompleted = 23,
  ReportDataField_ReportLockFaultCode = 24,
  ReportDataField_MIN = ReportDataField_NONE,
  ReportDataField_MAX = ReportDataField_ReportLockFaultCode
};

inline const ReportDataField (&EnumValuesReportDataField())[25] {
  static const ReportDataField values[] = {
    ReportDataField_NONE,
    ReportDataField_ReportBlueTrigger,
    ReportDataField_ReportSelfTest,
    ReportDataField_ReportSelfTestProcess,
    ReportDataField_ReportImage,
    ReportDataField_ReportRosMap,
    ReportDataField_ReportPose,
    ReportDataField_ReportCleanTime,
    ReportDataField_ReportCleanArea,
    ReportDataField_ReportAutoClean,
    ReportDataField_ReportTitleBar,
    ReportDataField_ReportScanQR,
    ReportDataField_ReportSiteInfo,
    ReportDataField_ReportRouteInfo,
    ReportDataField_ReportDownloadProgress,
    ReportDataField_ReportTestRealTimeStatus,
    ReportDataField_ErrorCode,
    ReportDataField_ReportPerson,
    ReportDataField_ReportElevator,
    ReportDataField_ReportPowerDown,
    ReportDataField_ReportOrientedPoint,
    ReportDataField_ReportFaultCode,
    ReportDataField_ReportRobotEvent,
    ReportDataField_ReportSlamMapSendCompleted,
    ReportDataField_ReportLockFaultCode
  };
  return values;
}

inline const char * const *EnumNamesReportDataField() {
  static const char * const names[26] = {
    "NONE",
    "ReportBlueTrigger",
    "ReportSelfTest",
    "ReportSelfTestProcess",
    "ReportImage",
    "ReportRosMap",
    "ReportPose",
    "ReportCleanTime",
    "ReportCleanArea",
    "ReportAutoClean",
    "ReportTitleBar",
    "ReportScanQR",
    "ReportSiteInfo",
    "ReportRouteInfo",
    "ReportDownloadProgress",
    "ReportTestRealTimeStatus",
    "ErrorCode",
    "ReportPerson",
    "ReportElevator",
    "ReportPowerDown",
    "ReportOrientedPoint",
    "ReportFaultCode",
    "ReportRobotEvent",
    "ReportSlamMapSendCompleted",
    "ReportLockFaultCode",
    nullptr
  };
  return names;
}

inline const char *EnumNameReportDataField(ReportDataField e) {
  if (flatbuffers::IsOutRange(e, ReportDataField_NONE, ReportDataField_ReportLockFaultCode)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReportDataField()[index];
}

template<typename T> struct ReportDataFieldTraits {
  static const ReportDataField enum_value = ReportDataField_NONE;
};

template<> struct ReportDataFieldTraits<swr::ReportBlueTrigger> {
  static const ReportDataField enum_value = ReportDataField_ReportBlueTrigger;
};

template<> struct ReportDataFieldTraits<swr::ReportSelfTest> {
  static const ReportDataField enum_value = ReportDataField_ReportSelfTest;
};

template<> struct ReportDataFieldTraits<swr::ReportSelfTestProcess> {
  static const ReportDataField enum_value = ReportDataField_ReportSelfTestProcess;
};

template<> struct ReportDataFieldTraits<swr::ReportImage> {
  static const ReportDataField enum_value = ReportDataField_ReportImage;
};

template<> struct ReportDataFieldTraits<swr::ReportRosMap> {
  static const ReportDataField enum_value = ReportDataField_ReportRosMap;
};

template<> struct ReportDataFieldTraits<swr::ReportPose> {
  static const ReportDataField enum_value = ReportDataField_ReportPose;
};

template<> struct ReportDataFieldTraits<swr::ReportCleanTime> {
  static const ReportDataField enum_value = ReportDataField_ReportCleanTime;
};

template<> struct ReportDataFieldTraits<swr::ReportCleanArea> {
  static const ReportDataField enum_value = ReportDataField_ReportCleanArea;
};

template<> struct ReportDataFieldTraits<swr::ReportAutoClean> {
  static const ReportDataField enum_value = ReportDataField_ReportAutoClean;
};

template<> struct ReportDataFieldTraits<swr::ReportTitleBar> {
  static const ReportDataField enum_value = ReportDataField_ReportTitleBar;
};

template<> struct ReportDataFieldTraits<swr::ReportScanQR> {
  static const ReportDataField enum_value = ReportDataField_ReportScanQR;
};

template<> struct ReportDataFieldTraits<swr::ReportSiteInfo> {
  static const ReportDataField enum_value = ReportDataField_ReportSiteInfo;
};

template<> struct ReportDataFieldTraits<swr::ReportRouteInfo> {
  static const ReportDataField enum_value = ReportDataField_ReportRouteInfo;
};

template<> struct ReportDataFieldTraits<swr::ReportDownloadProgress> {
  static const ReportDataField enum_value = ReportDataField_ReportDownloadProgress;
};

template<> struct ReportDataFieldTraits<swr::ReportTestRealTimeStatus> {
  static const ReportDataField enum_value = ReportDataField_ReportTestRealTimeStatus;
};

template<> struct ReportDataFieldTraits<swr::ErrorCode> {
  static const ReportDataField enum_value = ReportDataField_ErrorCode;
};

template<> struct ReportDataFieldTraits<swr::ReportPerson> {
  static const ReportDataField enum_value = ReportDataField_ReportPerson;
};

template<> struct ReportDataFieldTraits<swr::ReportElevator> {
  static const ReportDataField enum_value = ReportDataField_ReportElevator;
};

template<> struct ReportDataFieldTraits<swr::ReportPowerDown> {
  static const ReportDataField enum_value = ReportDataField_ReportPowerDown;
};

template<> struct ReportDataFieldTraits<swr::ReportOrientedPoint> {
  static const ReportDataField enum_value = ReportDataField_ReportOrientedPoint;
};

template<> struct ReportDataFieldTraits<swr::ReportFaultCode> {
  static const ReportDataField enum_value = ReportDataField_ReportFaultCode;
};

template<> struct ReportDataFieldTraits<swr::ReportRobotEvent> {
  static const ReportDataField enum_value = ReportDataField_ReportRobotEvent;
};

template<> struct ReportDataFieldTraits<swr::ReportSlamMapSendCompleted> {
  static const ReportDataField enum_value = ReportDataField_ReportSlamMapSendCompleted;
};

template<> struct ReportDataFieldTraits<swr::ReportLockFaultCode> {
  static const ReportDataField enum_value = ReportDataField_ReportLockFaultCode;
};

bool VerifyReportDataField(flatbuffers::Verifier &verifier, const void *obj, ReportDataField type);
bool VerifyReportDataFieldVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct ReportBlueTrigger FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReportBlueTriggerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRIGGER = 4
  };
  bool trigger() const {
    return GetField<uint8_t>(VT_TRIGGER, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TRIGGER) &&
           verifier.EndTable();
  }
};

struct ReportBlueTriggerBuilder {
  typedef ReportBlueTrigger Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_trigger(bool trigger) {
    fbb_.AddElement<uint8_t>(ReportBlueTrigger::VT_TRIGGER, static_cast<uint8_t>(trigger), 0);
  }
  explicit ReportBlueTriggerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReportBlueTriggerBuilder &operator=(const ReportBlueTriggerBuilder &);
  flatbuffers::Offset<ReportBlueTrigger> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReportBlueTrigger>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReportBlueTrigger> CreateReportBlueTrigger(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool trigger = false) {
  ReportBlueTriggerBuilder builder_(_fbb);
  builder_.add_trigger(trigger);
  return builder_.Finish();
}

struct ReportSelfTestProcess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReportSelfTestProcessBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OVER = 4,
    VT_ALL = 6
  };
  int32_t over() const {
    return GetField<int32_t>(VT_OVER, 0);
  }
  int32_t all() const {
    return GetField<int32_t>(VT_ALL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OVER) &&
           VerifyField<int32_t>(verifier, VT_ALL) &&
           verifier.EndTable();
  }
};

struct ReportSelfTestProcessBuilder {
  typedef ReportSelfTestProcess Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_over(int32_t over) {
    fbb_.AddElement<int32_t>(ReportSelfTestProcess::VT_OVER, over, 0);
  }
  void add_all(int32_t all) {
    fbb_.AddElement<int32_t>(ReportSelfTestProcess::VT_ALL, all, 0);
  }
  explicit ReportSelfTestProcessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReportSelfTestProcessBuilder &operator=(const ReportSelfTestProcessBuilder &);
  flatbuffers::Offset<ReportSelfTestProcess> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReportSelfTestProcess>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReportSelfTestProcess> CreateReportSelfTestProcess(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t over = 0,
    int32_t all = 0) {
  ReportSelfTestProcessBuilder builder_(_fbb);
  builder_.add_all(all);
  builder_.add_over(over);
  return builder_.Finish();
}

struct ReportSelfTest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReportSelfTestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_LIST = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<swr::ErrorCode>> *error_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<swr::ErrorCode>> *>(VT_ERROR_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ERROR_LIST) &&
           verifier.VerifyVector(error_list()) &&
           verifier.VerifyVectorOfTables(error_list()) &&
           verifier.EndTable();
  }
};

struct ReportSelfTestBuilder {
  typedef ReportSelfTest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<swr::ErrorCode>>> error_list) {
    fbb_.AddOffset(ReportSelfTest::VT_ERROR_LIST, error_list);
  }
  explicit ReportSelfTestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReportSelfTestBuilder &operator=(const ReportSelfTestBuilder &);
  flatbuffers::Offset<ReportSelfTest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReportSelfTest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReportSelfTest> CreateReportSelfTest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<swr::ErrorCode>>> error_list = 0) {
  ReportSelfTestBuilder builder_(_fbb);
  builder_.add_error_list(error_list);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReportSelfTest> CreateReportSelfTestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<swr::ErrorCode>> *error_list = nullptr) {
  auto error_list__ = error_list ? _fbb.CreateVector<flatbuffers::Offset<swr::ErrorCode>>(*error_list) : 0;
  return swr::CreateReportSelfTest(
      _fbb,
      error_list__);
}

struct ReportImage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReportImageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_IMAGE = 6
  };
  double time() const {
    return GetField<double>(VT_TIME, 0.0);
  }
  const flatbuffers::Vector<uint8_t> *image() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_IMAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_IMAGE) &&
           verifier.VerifyVector(image()) &&
           verifier.EndTable();
  }
};

struct ReportImageBuilder {
  typedef ReportImage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(double time) {
    fbb_.AddElement<double>(ReportImage::VT_TIME, time, 0.0);
  }
  void add_image(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> image) {
    fbb_.AddOffset(ReportImage::VT_IMAGE, image);
  }
  explicit ReportImageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReportImageBuilder &operator=(const ReportImageBuilder &);
  flatbuffers::Offset<ReportImage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReportImage>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReportImage> CreateReportImage(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> image = 0) {
  ReportImageBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_image(image);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReportImage> CreateReportImageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    const std::vector<uint8_t> *image = nullptr) {
  auto image__ = image ? _fbb.CreateVector<uint8_t>(*image) : 0;
  return swr::CreateReportImage(
      _fbb,
      time,
      image__);
}

struct ReportRosMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReportRosMapBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_GRID_DATA = 6
  };
  int64_t time() const {
    return GetField<int64_t>(VT_TIME, 0);
  }
  const flatbuffers::Vector<float> *grid_data() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_GRID_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_GRID_DATA) &&
           verifier.VerifyVector(grid_data()) &&
           verifier.EndTable();
  }
};

struct ReportRosMapBuilder {
  typedef ReportRosMap Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(int64_t time) {
    fbb_.AddElement<int64_t>(ReportRosMap::VT_TIME, time, 0);
  }
  void add_grid_data(flatbuffers::Offset<flatbuffers::Vector<float>> grid_data) {
    fbb_.AddOffset(ReportRosMap::VT_GRID_DATA, grid_data);
  }
  explicit ReportRosMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReportRosMapBuilder &operator=(const ReportRosMapBuilder &);
  flatbuffers::Offset<ReportRosMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReportRosMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReportRosMap> CreateReportRosMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t time = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> grid_data = 0) {
  ReportRosMapBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_grid_data(grid_data);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReportRosMap> CreateReportRosMapDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t time = 0,
    const std::vector<float> *grid_data = nullptr) {
  auto grid_data__ = grid_data ? _fbb.CreateVector<float>(*grid_data) : 0;
  return swr::CreateReportRosMap(
      _fbb,
      time,
      grid_data__);
}

struct ReportPose FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReportPoseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8,
    VT_ANGLE = 10
  };
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float z() const {
    return GetField<float>(VT_Z, 0.0f);
  }
  float angle() const {
    return GetField<float>(VT_ANGLE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X) &&
           VerifyField<float>(verifier, VT_Y) &&
           VerifyField<float>(verifier, VT_Z) &&
           VerifyField<float>(verifier, VT_ANGLE) &&
           verifier.EndTable();
  }
};

struct ReportPoseBuilder {
  typedef ReportPose Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(float x) {
    fbb_.AddElement<float>(ReportPose::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(ReportPose::VT_Y, y, 0.0f);
  }
  void add_z(float z) {
    fbb_.AddElement<float>(ReportPose::VT_Z, z, 0.0f);
  }
  void add_angle(float angle) {
    fbb_.AddElement<float>(ReportPose::VT_ANGLE, angle, 0.0f);
  }
  explicit ReportPoseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReportPoseBuilder &operator=(const ReportPoseBuilder &);
  flatbuffers::Offset<ReportPose> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReportPose>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReportPose> CreateReportPose(
    flatbuffers::FlatBufferBuilder &_fbb,
    float x = 0.0f,
    float y = 0.0f,
    float z = 0.0f,
    float angle = 0.0f) {
  ReportPoseBuilder builder_(_fbb);
  builder_.add_angle(angle);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct ReportCleanTime FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReportCleanTimeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4
  };
  float time() const {
    return GetField<float>(VT_TIME, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_TIME) &&
           verifier.EndTable();
  }
};

struct ReportCleanTimeBuilder {
  typedef ReportCleanTime Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(float time) {
    fbb_.AddElement<float>(ReportCleanTime::VT_TIME, time, 0.0f);
  }
  explicit ReportCleanTimeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReportCleanTimeBuilder &operator=(const ReportCleanTimeBuilder &);
  flatbuffers::Offset<ReportCleanTime> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReportCleanTime>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReportCleanTime> CreateReportCleanTime(
    flatbuffers::FlatBufferBuilder &_fbb,
    float time = 0.0f) {
  ReportCleanTimeBuilder builder_(_fbb);
  builder_.add_time(time);
  return builder_.Finish();
}

struct ReportCleanArea FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReportCleanAreaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AREA = 4
  };
  float area() const {
    return GetField<float>(VT_AREA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_AREA) &&
           verifier.EndTable();
  }
};

struct ReportCleanAreaBuilder {
  typedef ReportCleanArea Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_area(float area) {
    fbb_.AddElement<float>(ReportCleanArea::VT_AREA, area, 0.0f);
  }
  explicit ReportCleanAreaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReportCleanAreaBuilder &operator=(const ReportCleanAreaBuilder &);
  flatbuffers::Offset<ReportCleanArea> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReportCleanArea>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReportCleanArea> CreateReportCleanArea(
    flatbuffers::FlatBufferBuilder &_fbb,
    float area = 0.0f) {
  ReportCleanAreaBuilder builder_(_fbb);
  builder_.add_area(area);
  return builder_.Finish();
}

struct ReportAutoClean FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReportAutoCleanBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATE = 4
  };
  swr::AutoCleanState state() const {
    return static_cast<swr::AutoCleanState>(GetField<int8_t>(VT_STATE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
};

struct ReportAutoCleanBuilder {
  typedef ReportAutoClean Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state(swr::AutoCleanState state) {
    fbb_.AddElement<int8_t>(ReportAutoClean::VT_STATE, static_cast<int8_t>(state), 0);
  }
  explicit ReportAutoCleanBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReportAutoCleanBuilder &operator=(const ReportAutoCleanBuilder &);
  flatbuffers::Offset<ReportAutoClean> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReportAutoClean>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReportAutoClean> CreateReportAutoClean(
    flatbuffers::FlatBufferBuilder &_fbb,
    swr::AutoCleanState state = swr::AutoCleanState_StartSuccess) {
  ReportAutoCleanBuilder builder_(_fbb);
  builder_.add_state(state);
  return builder_.Finish();
}

struct ReportCloudState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReportCloudStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATE = 4
  };
  bool state() const {
    return GetField<uint8_t>(VT_STATE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
};

struct ReportCloudStateBuilder {
  typedef ReportCloudState Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state(bool state) {
    fbb_.AddElement<uint8_t>(ReportCloudState::VT_STATE, static_cast<uint8_t>(state), 0);
  }
  explicit ReportCloudStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReportCloudStateBuilder &operator=(const ReportCloudStateBuilder &);
  flatbuffers::Offset<ReportCloudState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReportCloudState>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReportCloudState> CreateReportCloudState(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool state = false) {
  ReportCloudStateBuilder builder_(_fbb);
  builder_.add_state(state);
  return builder_.Finish();
}

struct ReportNetLevel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReportNetLevelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIFI = 4,
    VT_FOUR_G = 6
  };
  int32_t wifi() const {
    return GetField<int32_t>(VT_WIFI, 0);
  }
  int32_t four_g() const {
    return GetField<int32_t>(VT_FOUR_G, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_WIFI) &&
           VerifyField<int32_t>(verifier, VT_FOUR_G) &&
           verifier.EndTable();
  }
};

struct ReportNetLevelBuilder {
  typedef ReportNetLevel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_wifi(int32_t wifi) {
    fbb_.AddElement<int32_t>(ReportNetLevel::VT_WIFI, wifi, 0);
  }
  void add_four_g(int32_t four_g) {
    fbb_.AddElement<int32_t>(ReportNetLevel::VT_FOUR_G, four_g, 0);
  }
  explicit ReportNetLevelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReportNetLevelBuilder &operator=(const ReportNetLevelBuilder &);
  flatbuffers::Offset<ReportNetLevel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReportNetLevel>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReportNetLevel> CreateReportNetLevel(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t wifi = 0,
    int32_t four_g = 0) {
  ReportNetLevelBuilder builder_(_fbb);
  builder_.add_four_g(four_g);
  builder_.add_wifi(wifi);
  return builder_.Finish();
}

struct ReportBatteryLevel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReportBatteryLevelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BATTERY = 4,
    VT_CHARGING = 6
  };
  float battery() const {
    return GetField<float>(VT_BATTERY, 0.0f);
  }
  bool charging() const {
    return GetField<uint8_t>(VT_CHARGING, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BATTERY) &&
           VerifyField<uint8_t>(verifier, VT_CHARGING) &&
           verifier.EndTable();
  }
};

struct ReportBatteryLevelBuilder {
  typedef ReportBatteryLevel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_battery(float battery) {
    fbb_.AddElement<float>(ReportBatteryLevel::VT_BATTERY, battery, 0.0f);
  }
  void add_charging(bool charging) {
    fbb_.AddElement<uint8_t>(ReportBatteryLevel::VT_CHARGING, static_cast<uint8_t>(charging), 0);
  }
  explicit ReportBatteryLevelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReportBatteryLevelBuilder &operator=(const ReportBatteryLevelBuilder &);
  flatbuffers::Offset<ReportBatteryLevel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReportBatteryLevel>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReportBatteryLevel> CreateReportBatteryLevel(
    flatbuffers::FlatBufferBuilder &_fbb,
    float battery = 0.0f,
    bool charging = false) {
  ReportBatteryLevelBuilder builder_(_fbb);
  builder_.add_battery(battery);
  builder_.add_charging(charging);
  return builder_.Finish();
}

struct ReportTitleBar FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReportTitleBarBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_DATA_TYPE = 6,
    VT_DATA = 8
  };
  swr::ReportTitleBarType type() const {
    return static_cast<swr::ReportTitleBarType>(GetField<int8_t>(VT_TYPE, 0));
  }
  swr::ReportTitleBarData data_type() const {
    return static_cast<swr::ReportTitleBarData>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const swr::ReportCloudState *data_as_ReportCloudState() const {
    return data_type() == swr::ReportTitleBarData_ReportCloudState ? static_cast<const swr::ReportCloudState *>(data()) : nullptr;
  }
  const swr::ReportNetLevel *data_as_ReportNetLevel() const {
    return data_type() == swr::ReportTitleBarData_ReportNetLevel ? static_cast<const swr::ReportNetLevel *>(data()) : nullptr;
  }
  const swr::ReportBatteryLevel *data_as_ReportBatteryLevel() const {
    return data_type() == swr::ReportTitleBarData_ReportBatteryLevel ? static_cast<const swr::ReportBatteryLevel *>(data()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyReportTitleBarData(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

template<> inline const swr::ReportCloudState *ReportTitleBar::data_as<swr::ReportCloudState>() const {
  return data_as_ReportCloudState();
}

template<> inline const swr::ReportNetLevel *ReportTitleBar::data_as<swr::ReportNetLevel>() const {
  return data_as_ReportNetLevel();
}

template<> inline const swr::ReportBatteryLevel *ReportTitleBar::data_as<swr::ReportBatteryLevel>() const {
  return data_as_ReportBatteryLevel();
}

struct ReportTitleBarBuilder {
  typedef ReportTitleBar Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(swr::ReportTitleBarType type) {
    fbb_.AddElement<int8_t>(ReportTitleBar::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_data_type(swr::ReportTitleBarData data_type) {
    fbb_.AddElement<uint8_t>(ReportTitleBar::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(flatbuffers::Offset<void> data) {
    fbb_.AddOffset(ReportTitleBar::VT_DATA, data);
  }
  explicit ReportTitleBarBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReportTitleBarBuilder &operator=(const ReportTitleBarBuilder &);
  flatbuffers::Offset<ReportTitleBar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReportTitleBar>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReportTitleBar> CreateReportTitleBar(
    flatbuffers::FlatBufferBuilder &_fbb,
    swr::ReportTitleBarType type = swr::ReportTitleBarType_ReportCloudState,
    swr::ReportTitleBarData data_type = swr::ReportTitleBarData_NONE,
    flatbuffers::Offset<void> data = 0) {
  ReportTitleBarBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  builder_.add_type(type);
  return builder_.Finish();
}

struct ReportDistinguishRLT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReportDistinguishRLTBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LTX = 4,
    VT_LTY = 6,
    VT_RTX = 8,
    VT_RTY = 10,
    VT_LBX = 12,
    VT_LBY = 14,
    VT_RBX = 16,
    VT_RBY = 18
  };
  int32_t ltx() const {
    return GetField<int32_t>(VT_LTX, 0);
  }
  int32_t lty() const {
    return GetField<int32_t>(VT_LTY, 0);
  }
  int32_t rtx() const {
    return GetField<int32_t>(VT_RTX, 0);
  }
  int32_t rty() const {
    return GetField<int32_t>(VT_RTY, 0);
  }
  int32_t lbx() const {
    return GetField<int32_t>(VT_LBX, 0);
  }
  int32_t lby() const {
    return GetField<int32_t>(VT_LBY, 0);
  }
  int32_t rbx() const {
    return GetField<int32_t>(VT_RBX, 0);
  }
  int32_t rby() const {
    return GetField<int32_t>(VT_RBY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LTX) &&
           VerifyField<int32_t>(verifier, VT_LTY) &&
           VerifyField<int32_t>(verifier, VT_RTX) &&
           VerifyField<int32_t>(verifier, VT_RTY) &&
           VerifyField<int32_t>(verifier, VT_LBX) &&
           VerifyField<int32_t>(verifier, VT_LBY) &&
           VerifyField<int32_t>(verifier, VT_RBX) &&
           VerifyField<int32_t>(verifier, VT_RBY) &&
           verifier.EndTable();
  }
};

struct ReportDistinguishRLTBuilder {
  typedef ReportDistinguishRLT Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ltx(int32_t ltx) {
    fbb_.AddElement<int32_t>(ReportDistinguishRLT::VT_LTX, ltx, 0);
  }
  void add_lty(int32_t lty) {
    fbb_.AddElement<int32_t>(ReportDistinguishRLT::VT_LTY, lty, 0);
  }
  void add_rtx(int32_t rtx) {
    fbb_.AddElement<int32_t>(ReportDistinguishRLT::VT_RTX, rtx, 0);
  }
  void add_rty(int32_t rty) {
    fbb_.AddElement<int32_t>(ReportDistinguishRLT::VT_RTY, rty, 0);
  }
  void add_lbx(int32_t lbx) {
    fbb_.AddElement<int32_t>(ReportDistinguishRLT::VT_LBX, lbx, 0);
  }
  void add_lby(int32_t lby) {
    fbb_.AddElement<int32_t>(ReportDistinguishRLT::VT_LBY, lby, 0);
  }
  void add_rbx(int32_t rbx) {
    fbb_.AddElement<int32_t>(ReportDistinguishRLT::VT_RBX, rbx, 0);
  }
  void add_rby(int32_t rby) {
    fbb_.AddElement<int32_t>(ReportDistinguishRLT::VT_RBY, rby, 0);
  }
  explicit ReportDistinguishRLTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReportDistinguishRLTBuilder &operator=(const ReportDistinguishRLTBuilder &);
  flatbuffers::Offset<ReportDistinguishRLT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReportDistinguishRLT>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReportDistinguishRLT> CreateReportDistinguishRLT(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ltx = 0,
    int32_t lty = 0,
    int32_t rtx = 0,
    int32_t rty = 0,
    int32_t lbx = 0,
    int32_t lby = 0,
    int32_t rbx = 0,
    int32_t rby = 0) {
  ReportDistinguishRLTBuilder builder_(_fbb);
  builder_.add_rby(rby);
  builder_.add_rbx(rbx);
  builder_.add_lby(lby);
  builder_.add_lbx(lbx);
  builder_.add_rty(rty);
  builder_.add_rtx(rtx);
  builder_.add_lty(lty);
  builder_.add_ltx(ltx);
  return builder_.Finish();
}

struct ReportCalculateRLT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReportCalculateRLTBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SITE_CODE = 4,
    VT_HLC_CODE = 6
  };
  const flatbuffers::String *site_code() const {
    return GetPointer<const flatbuffers::String *>(VT_SITE_CODE);
  }
  const flatbuffers::String *hlc_code() const {
    return GetPointer<const flatbuffers::String *>(VT_HLC_CODE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SITE_CODE) &&
           verifier.VerifyString(site_code()) &&
           VerifyOffset(verifier, VT_HLC_CODE) &&
           verifier.VerifyString(hlc_code()) &&
           verifier.EndTable();
  }
};

struct ReportCalculateRLTBuilder {
  typedef ReportCalculateRLT Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_site_code(flatbuffers::Offset<flatbuffers::String> site_code) {
    fbb_.AddOffset(ReportCalculateRLT::VT_SITE_CODE, site_code);
  }
  void add_hlc_code(flatbuffers::Offset<flatbuffers::String> hlc_code) {
    fbb_.AddOffset(ReportCalculateRLT::VT_HLC_CODE, hlc_code);
  }
  explicit ReportCalculateRLTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReportCalculateRLTBuilder &operator=(const ReportCalculateRLTBuilder &);
  flatbuffers::Offset<ReportCalculateRLT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReportCalculateRLT>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReportCalculateRLT> CreateReportCalculateRLT(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> site_code = 0,
    flatbuffers::Offset<flatbuffers::String> hlc_code = 0) {
  ReportCalculateRLTBuilder builder_(_fbb);
  builder_.add_hlc_code(hlc_code);
  builder_.add_site_code(site_code);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReportCalculateRLT> CreateReportCalculateRLTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *site_code = nullptr,
    const char *hlc_code = nullptr) {
  auto site_code__ = site_code ? _fbb.CreateString(site_code) : 0;
  auto hlc_code__ = hlc_code ? _fbb.CreateString(hlc_code) : 0;
  return swr::CreateReportCalculateRLT(
      _fbb,
      site_code__,
      hlc_code__);
}

struct ReportScanQR FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReportScanQRBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4,
    VT_TYPE = 6,
    VT_RESULT_TYPE = 8,
    VT_RESULT = 10
  };
  swr::MarkerState code() const {
    return static_cast<swr::MarkerState>(GetField<int8_t>(VT_CODE, 0));
  }
  swr::ReprotMarkerType type() const {
    return static_cast<swr::ReprotMarkerType>(GetField<int8_t>(VT_TYPE, 0));
  }
  swr::ReportMarkerRLT result_type() const {
    return static_cast<swr::ReportMarkerRLT>(GetField<uint8_t>(VT_RESULT_TYPE, 0));
  }
  const void *result() const {
    return GetPointer<const void *>(VT_RESULT);
  }
  template<typename T> const T *result_as() const;
  const swr::ReportDistinguishRLT *result_as_ReportDistinguishRLT() const {
    return result_type() == swr::ReportMarkerRLT_ReportDistinguishRLT ? static_cast<const swr::ReportDistinguishRLT *>(result()) : nullptr;
  }
  const swr::ReportCalculateRLT *result_as_ReportCalculateRLT() const {
    return result_type() == swr::ReportMarkerRLT_ReportCalculateRLT ? static_cast<const swr::ReportCalculateRLT *>(result()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_CODE) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_RESULT_TYPE) &&
           VerifyOffset(verifier, VT_RESULT) &&
           VerifyReportMarkerRLT(verifier, result(), result_type()) &&
           verifier.EndTable();
  }
};

template<> inline const swr::ReportDistinguishRLT *ReportScanQR::result_as<swr::ReportDistinguishRLT>() const {
  return result_as_ReportDistinguishRLT();
}

template<> inline const swr::ReportCalculateRLT *ReportScanQR::result_as<swr::ReportCalculateRLT>() const {
  return result_as_ReportCalculateRLT();
}

struct ReportScanQRBuilder {
  typedef ReportScanQR Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(swr::MarkerState code) {
    fbb_.AddElement<int8_t>(ReportScanQR::VT_CODE, static_cast<int8_t>(code), 0);
  }
  void add_type(swr::ReprotMarkerType type) {
    fbb_.AddElement<int8_t>(ReportScanQR::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_result_type(swr::ReportMarkerRLT result_type) {
    fbb_.AddElement<uint8_t>(ReportScanQR::VT_RESULT_TYPE, static_cast<uint8_t>(result_type), 0);
  }
  void add_result(flatbuffers::Offset<void> result) {
    fbb_.AddOffset(ReportScanQR::VT_RESULT, result);
  }
  explicit ReportScanQRBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReportScanQRBuilder &operator=(const ReportScanQRBuilder &);
  flatbuffers::Offset<ReportScanQR> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReportScanQR>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReportScanQR> CreateReportScanQR(
    flatbuffers::FlatBufferBuilder &_fbb,
    swr::MarkerState code = swr::MarkerState_Success,
    swr::ReprotMarkerType type = swr::ReprotMarkerType_MarkerTypeDistinguish,
    swr::ReportMarkerRLT result_type = swr::ReportMarkerRLT_NONE,
    flatbuffers::Offset<void> result = 0) {
  ReportScanQRBuilder builder_(_fbb);
  builder_.add_result(result);
  builder_.add_result_type(result_type);
  builder_.add_type(type);
  builder_.add_code(code);
  return builder_.Finish();
}

struct ReportSiteInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReportSiteInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SITE_CODE = 4,
    VT_SITE_NAME = 6,
    VT_FLOOR_NAME = 8,
    VT_LOCATION_NAME = 10
  };
  const flatbuffers::String *site_code() const {
    return GetPointer<const flatbuffers::String *>(VT_SITE_CODE);
  }
  const flatbuffers::String *site_name() const {
    return GetPointer<const flatbuffers::String *>(VT_SITE_NAME);
  }
  const flatbuffers::String *floor_name() const {
    return GetPointer<const flatbuffers::String *>(VT_FLOOR_NAME);
  }
  const flatbuffers::String *location_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LOCATION_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SITE_CODE) &&
           verifier.VerifyString(site_code()) &&
           VerifyOffset(verifier, VT_SITE_NAME) &&
           verifier.VerifyString(site_name()) &&
           VerifyOffset(verifier, VT_FLOOR_NAME) &&
           verifier.VerifyString(floor_name()) &&
           VerifyOffset(verifier, VT_LOCATION_NAME) &&
           verifier.VerifyString(location_name()) &&
           verifier.EndTable();
  }
};

struct ReportSiteInfoBuilder {
  typedef ReportSiteInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_site_code(flatbuffers::Offset<flatbuffers::String> site_code) {
    fbb_.AddOffset(ReportSiteInfo::VT_SITE_CODE, site_code);
  }
  void add_site_name(flatbuffers::Offset<flatbuffers::String> site_name) {
    fbb_.AddOffset(ReportSiteInfo::VT_SITE_NAME, site_name);
  }
  void add_floor_name(flatbuffers::Offset<flatbuffers::String> floor_name) {
    fbb_.AddOffset(ReportSiteInfo::VT_FLOOR_NAME, floor_name);
  }
  void add_location_name(flatbuffers::Offset<flatbuffers::String> location_name) {
    fbb_.AddOffset(ReportSiteInfo::VT_LOCATION_NAME, location_name);
  }
  explicit ReportSiteInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReportSiteInfoBuilder &operator=(const ReportSiteInfoBuilder &);
  flatbuffers::Offset<ReportSiteInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReportSiteInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReportSiteInfo> CreateReportSiteInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> site_code = 0,
    flatbuffers::Offset<flatbuffers::String> site_name = 0,
    flatbuffers::Offset<flatbuffers::String> floor_name = 0,
    flatbuffers::Offset<flatbuffers::String> location_name = 0) {
  ReportSiteInfoBuilder builder_(_fbb);
  builder_.add_location_name(location_name);
  builder_.add_floor_name(floor_name);
  builder_.add_site_name(site_name);
  builder_.add_site_code(site_code);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReportSiteInfo> CreateReportSiteInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *site_code = nullptr,
    const char *site_name = nullptr,
    const char *floor_name = nullptr,
    const char *location_name = nullptr) {
  auto site_code__ = site_code ? _fbb.CreateString(site_code) : 0;
  auto site_name__ = site_name ? _fbb.CreateString(site_name) : 0;
  auto floor_name__ = floor_name ? _fbb.CreateString(floor_name) : 0;
  auto location_name__ = location_name ? _fbb.CreateString(location_name) : 0;
  return swr::CreateReportSiteInfo(
      _fbb,
      site_code__,
      site_name__,
      floor_name__,
      location_name__);
}

struct ReportRouteInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReportRouteInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROUTE_LIST = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<swr::RouteInfo>> *route_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<swr::RouteInfo>> *>(VT_ROUTE_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROUTE_LIST) &&
           verifier.VerifyVector(route_list()) &&
           verifier.VerifyVectorOfTables(route_list()) &&
           verifier.EndTable();
  }
};

struct ReportRouteInfoBuilder {
  typedef ReportRouteInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_route_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<swr::RouteInfo>>> route_list) {
    fbb_.AddOffset(ReportRouteInfo::VT_ROUTE_LIST, route_list);
  }
  explicit ReportRouteInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReportRouteInfoBuilder &operator=(const ReportRouteInfoBuilder &);
  flatbuffers::Offset<ReportRouteInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReportRouteInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReportRouteInfo> CreateReportRouteInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<swr::RouteInfo>>> route_list = 0) {
  ReportRouteInfoBuilder builder_(_fbb);
  builder_.add_route_list(route_list);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReportRouteInfo> CreateReportRouteInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<swr::RouteInfo>> *route_list = nullptr) {
  auto route_list__ = route_list ? _fbb.CreateVector<flatbuffers::Offset<swr::RouteInfo>>(*route_list) : 0;
  return swr::CreateReportRouteInfo(
      _fbb,
      route_list__);
}

struct ReportDownloadProgress FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReportDownloadProgressBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SITE_CODE = 4,
    VT_HLC_CODE = 6,
    VT_SLOT_CODE = 8,
    VT_ROUTE_ID = 10,
    VT_TYPE = 12,
    VT_PROGRESS = 14,
    VT_PNG_FINISH = 16
  };
  const flatbuffers::String *site_code() const {
    return GetPointer<const flatbuffers::String *>(VT_SITE_CODE);
  }
  const flatbuffers::String *hlc_code() const {
    return GetPointer<const flatbuffers::String *>(VT_HLC_CODE);
  }
  uint8_t slot_code() const {
    return GetField<uint8_t>(VT_SLOT_CODE, 0);
  }
  const flatbuffers::String *route_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ROUTE_ID);
  }
  swr::DownloadDataType type() const {
    return static_cast<swr::DownloadDataType>(GetField<int8_t>(VT_TYPE, 0));
  }
  int32_t progress() const {
    return GetField<int32_t>(VT_PROGRESS, 0);
  }
  bool png_finish() const {
    return GetField<uint8_t>(VT_PNG_FINISH, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SITE_CODE) &&
           verifier.VerifyString(site_code()) &&
           VerifyOffset(verifier, VT_HLC_CODE) &&
           verifier.VerifyString(hlc_code()) &&
           VerifyField<uint8_t>(verifier, VT_SLOT_CODE) &&
           VerifyOffset(verifier, VT_ROUTE_ID) &&
           verifier.VerifyString(route_id()) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_PROGRESS) &&
           VerifyField<uint8_t>(verifier, VT_PNG_FINISH) &&
           verifier.EndTable();
  }
};

struct ReportDownloadProgressBuilder {
  typedef ReportDownloadProgress Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_site_code(flatbuffers::Offset<flatbuffers::String> site_code) {
    fbb_.AddOffset(ReportDownloadProgress::VT_SITE_CODE, site_code);
  }
  void add_hlc_code(flatbuffers::Offset<flatbuffers::String> hlc_code) {
    fbb_.AddOffset(ReportDownloadProgress::VT_HLC_CODE, hlc_code);
  }
  void add_slot_code(uint8_t slot_code) {
    fbb_.AddElement<uint8_t>(ReportDownloadProgress::VT_SLOT_CODE, slot_code, 0);
  }
  void add_route_id(flatbuffers::Offset<flatbuffers::String> route_id) {
    fbb_.AddOffset(ReportDownloadProgress::VT_ROUTE_ID, route_id);
  }
  void add_type(swr::DownloadDataType type) {
    fbb_.AddElement<int8_t>(ReportDownloadProgress::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_progress(int32_t progress) {
    fbb_.AddElement<int32_t>(ReportDownloadProgress::VT_PROGRESS, progress, 0);
  }
  void add_png_finish(bool png_finish) {
    fbb_.AddElement<uint8_t>(ReportDownloadProgress::VT_PNG_FINISH, static_cast<uint8_t>(png_finish), 0);
  }
  explicit ReportDownloadProgressBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReportDownloadProgressBuilder &operator=(const ReportDownloadProgressBuilder &);
  flatbuffers::Offset<ReportDownloadProgress> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReportDownloadProgress>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReportDownloadProgress> CreateReportDownloadProgress(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> site_code = 0,
    flatbuffers::Offset<flatbuffers::String> hlc_code = 0,
    uint8_t slot_code = 0,
    flatbuffers::Offset<flatbuffers::String> route_id = 0,
    swr::DownloadDataType type = swr::DownloadDataType_Invalid,
    int32_t progress = 0,
    bool png_finish = false) {
  ReportDownloadProgressBuilder builder_(_fbb);
  builder_.add_progress(progress);
  builder_.add_route_id(route_id);
  builder_.add_hlc_code(hlc_code);
  builder_.add_site_code(site_code);
  builder_.add_png_finish(png_finish);
  builder_.add_type(type);
  builder_.add_slot_code(slot_code);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReportDownloadProgress> CreateReportDownloadProgressDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *site_code = nullptr,
    const char *hlc_code = nullptr,
    uint8_t slot_code = 0,
    const char *route_id = nullptr,
    swr::DownloadDataType type = swr::DownloadDataType_Invalid,
    int32_t progress = 0,
    bool png_finish = false) {
  auto site_code__ = site_code ? _fbb.CreateString(site_code) : 0;
  auto hlc_code__ = hlc_code ? _fbb.CreateString(hlc_code) : 0;
  auto route_id__ = route_id ? _fbb.CreateString(route_id) : 0;
  return swr::CreateReportDownloadProgress(
      _fbb,
      site_code__,
      hlc_code__,
      slot_code,
      route_id__,
      type,
      progress,
      png_finish);
}

struct ReportTestRealTimeStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReportTestRealTimeStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAIN_BRUSH_MOTOR_CURRENT = 4,
    VT_SUCTION_PUMP_CURRENT = 6,
    VT_LEFT_BRUSH_MOTOR_CURRENT = 8,
    VT_RIGHT_BRUSH_MOTOR_CURRENT = 10,
    VT_PUSHER_CURRENT_OF_COIL_LINE = 12,
    VT_WIPER_WIRE_PUSHER_CURRENT = 14,
    VT_LEFT_BRAKE_ASSEMBLY = 16,
    VT_RIGHT_BRAKE_ASSEMBLY = 18,
    VT_LEFT_DRIVE_CURRENT = 20,
    VT_RIGHT_DRIVE_CURRENT = 22
  };
  float main_brush_motor_current() const {
    return GetField<float>(VT_MAIN_BRUSH_MOTOR_CURRENT, 0.0f);
  }
  float suction_pump_current() const {
    return GetField<float>(VT_SUCTION_PUMP_CURRENT, 0.0f);
  }
  float left_brush_motor_current() const {
    return GetField<float>(VT_LEFT_BRUSH_MOTOR_CURRENT, 0.0f);
  }
  float right_brush_motor_current() const {
    return GetField<float>(VT_RIGHT_BRUSH_MOTOR_CURRENT, 0.0f);
  }
  float pusher_current_of_coil_line() const {
    return GetField<float>(VT_PUSHER_CURRENT_OF_COIL_LINE, 0.0f);
  }
  float wiper_wire_pusher_current() const {
    return GetField<float>(VT_WIPER_WIRE_PUSHER_CURRENT, 0.0f);
  }
  float left_brake_assembly() const {
    return GetField<float>(VT_LEFT_BRAKE_ASSEMBLY, 0.0f);
  }
  float right_brake_assembly() const {
    return GetField<float>(VT_RIGHT_BRAKE_ASSEMBLY, 0.0f);
  }
  float left_drive_current() const {
    return GetField<float>(VT_LEFT_DRIVE_CURRENT, 0.0f);
  }
  float right_drive_current() const {
    return GetField<float>(VT_RIGHT_DRIVE_CURRENT, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_MAIN_BRUSH_MOTOR_CURRENT) &&
           VerifyField<float>(verifier, VT_SUCTION_PUMP_CURRENT) &&
           VerifyField<float>(verifier, VT_LEFT_BRUSH_MOTOR_CURRENT) &&
           VerifyField<float>(verifier, VT_RIGHT_BRUSH_MOTOR_CURRENT) &&
           VerifyField<float>(verifier, VT_PUSHER_CURRENT_OF_COIL_LINE) &&
           VerifyField<float>(verifier, VT_WIPER_WIRE_PUSHER_CURRENT) &&
           VerifyField<float>(verifier, VT_LEFT_BRAKE_ASSEMBLY) &&
           VerifyField<float>(verifier, VT_RIGHT_BRAKE_ASSEMBLY) &&
           VerifyField<float>(verifier, VT_LEFT_DRIVE_CURRENT) &&
           VerifyField<float>(verifier, VT_RIGHT_DRIVE_CURRENT) &&
           verifier.EndTable();
  }
};

struct ReportTestRealTimeStatusBuilder {
  typedef ReportTestRealTimeStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_main_brush_motor_current(float main_brush_motor_current) {
    fbb_.AddElement<float>(ReportTestRealTimeStatus::VT_MAIN_BRUSH_MOTOR_CURRENT, main_brush_motor_current, 0.0f);
  }
  void add_suction_pump_current(float suction_pump_current) {
    fbb_.AddElement<float>(ReportTestRealTimeStatus::VT_SUCTION_PUMP_CURRENT, suction_pump_current, 0.0f);
  }
  void add_left_brush_motor_current(float left_brush_motor_current) {
    fbb_.AddElement<float>(ReportTestRealTimeStatus::VT_LEFT_BRUSH_MOTOR_CURRENT, left_brush_motor_current, 0.0f);
  }
  void add_right_brush_motor_current(float right_brush_motor_current) {
    fbb_.AddElement<float>(ReportTestRealTimeStatus::VT_RIGHT_BRUSH_MOTOR_CURRENT, right_brush_motor_current, 0.0f);
  }
  void add_pusher_current_of_coil_line(float pusher_current_of_coil_line) {
    fbb_.AddElement<float>(ReportTestRealTimeStatus::VT_PUSHER_CURRENT_OF_COIL_LINE, pusher_current_of_coil_line, 0.0f);
  }
  void add_wiper_wire_pusher_current(float wiper_wire_pusher_current) {
    fbb_.AddElement<float>(ReportTestRealTimeStatus::VT_WIPER_WIRE_PUSHER_CURRENT, wiper_wire_pusher_current, 0.0f);
  }
  void add_left_brake_assembly(float left_brake_assembly) {
    fbb_.AddElement<float>(ReportTestRealTimeStatus::VT_LEFT_BRAKE_ASSEMBLY, left_brake_assembly, 0.0f);
  }
  void add_right_brake_assembly(float right_brake_assembly) {
    fbb_.AddElement<float>(ReportTestRealTimeStatus::VT_RIGHT_BRAKE_ASSEMBLY, right_brake_assembly, 0.0f);
  }
  void add_left_drive_current(float left_drive_current) {
    fbb_.AddElement<float>(ReportTestRealTimeStatus::VT_LEFT_DRIVE_CURRENT, left_drive_current, 0.0f);
  }
  void add_right_drive_current(float right_drive_current) {
    fbb_.AddElement<float>(ReportTestRealTimeStatus::VT_RIGHT_DRIVE_CURRENT, right_drive_current, 0.0f);
  }
  explicit ReportTestRealTimeStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReportTestRealTimeStatusBuilder &operator=(const ReportTestRealTimeStatusBuilder &);
  flatbuffers::Offset<ReportTestRealTimeStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReportTestRealTimeStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReportTestRealTimeStatus> CreateReportTestRealTimeStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    float main_brush_motor_current = 0.0f,
    float suction_pump_current = 0.0f,
    float left_brush_motor_current = 0.0f,
    float right_brush_motor_current = 0.0f,
    float pusher_current_of_coil_line = 0.0f,
    float wiper_wire_pusher_current = 0.0f,
    float left_brake_assembly = 0.0f,
    float right_brake_assembly = 0.0f,
    float left_drive_current = 0.0f,
    float right_drive_current = 0.0f) {
  ReportTestRealTimeStatusBuilder builder_(_fbb);
  builder_.add_right_drive_current(right_drive_current);
  builder_.add_left_drive_current(left_drive_current);
  builder_.add_right_brake_assembly(right_brake_assembly);
  builder_.add_left_brake_assembly(left_brake_assembly);
  builder_.add_wiper_wire_pusher_current(wiper_wire_pusher_current);
  builder_.add_pusher_current_of_coil_line(pusher_current_of_coil_line);
  builder_.add_right_brush_motor_current(right_brush_motor_current);
  builder_.add_left_brush_motor_current(left_brush_motor_current);
  builder_.add_suction_pump_current(suction_pump_current);
  builder_.add_main_brush_motor_current(main_brush_motor_current);
  return builder_.Finish();
}

struct ReportPerson FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReportPersonBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PERSON_LIST = 4
  };
  const flatbuffers::Vector<const swr::PersonPoint *> *person_list() const {
    return GetPointer<const flatbuffers::Vector<const swr::PersonPoint *> *>(VT_PERSON_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PERSON_LIST) &&
           verifier.VerifyVector(person_list()) &&
           verifier.EndTable();
  }
};

struct ReportPersonBuilder {
  typedef ReportPerson Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_person_list(flatbuffers::Offset<flatbuffers::Vector<const swr::PersonPoint *>> person_list) {
    fbb_.AddOffset(ReportPerson::VT_PERSON_LIST, person_list);
  }
  explicit ReportPersonBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReportPersonBuilder &operator=(const ReportPersonBuilder &);
  flatbuffers::Offset<ReportPerson> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReportPerson>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReportPerson> CreateReportPerson(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const swr::PersonPoint *>> person_list = 0) {
  ReportPersonBuilder builder_(_fbb);
  builder_.add_person_list(person_list);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReportPerson> CreateReportPersonDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<swr::PersonPoint> *person_list = nullptr) {
  auto person_list__ = person_list ? _fbb.CreateVectorOfStructs<swr::PersonPoint>(*person_list) : 0;
  return swr::CreateReportPerson(
      _fbb,
      person_list__);
}

struct ReportElevator FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReportElevatorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEVATOR_LIST = 4
  };
  const flatbuffers::Vector<const swr::ElevatorPoint *> *elevator_list() const {
    return GetPointer<const flatbuffers::Vector<const swr::ElevatorPoint *> *>(VT_ELEVATOR_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ELEVATOR_LIST) &&
           verifier.VerifyVector(elevator_list()) &&
           verifier.EndTable();
  }
};

struct ReportElevatorBuilder {
  typedef ReportElevator Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_elevator_list(flatbuffers::Offset<flatbuffers::Vector<const swr::ElevatorPoint *>> elevator_list) {
    fbb_.AddOffset(ReportElevator::VT_ELEVATOR_LIST, elevator_list);
  }
  explicit ReportElevatorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReportElevatorBuilder &operator=(const ReportElevatorBuilder &);
  flatbuffers::Offset<ReportElevator> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReportElevator>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReportElevator> CreateReportElevator(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const swr::ElevatorPoint *>> elevator_list = 0) {
  ReportElevatorBuilder builder_(_fbb);
  builder_.add_elevator_list(elevator_list);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReportElevator> CreateReportElevatorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<swr::ElevatorPoint> *elevator_list = nullptr) {
  auto elevator_list__ = elevator_list ? _fbb.CreateVectorOfStructs<swr::ElevatorPoint>(*elevator_list) : 0;
  return swr::CreateReportElevator(
      _fbb,
      elevator_list__);
}

struct ReportPowerDown FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReportPowerDownBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRIGGER = 4
  };
  bool trigger() const {
    return GetField<uint8_t>(VT_TRIGGER, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TRIGGER) &&
           verifier.EndTable();
  }
};

struct ReportPowerDownBuilder {
  typedef ReportPowerDown Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_trigger(bool trigger) {
    fbb_.AddElement<uint8_t>(ReportPowerDown::VT_TRIGGER, static_cast<uint8_t>(trigger), 0);
  }
  explicit ReportPowerDownBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReportPowerDownBuilder &operator=(const ReportPowerDownBuilder &);
  flatbuffers::Offset<ReportPowerDown> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReportPowerDown>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReportPowerDown> CreateReportPowerDown(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool trigger = false) {
  ReportPowerDownBuilder builder_(_fbb);
  builder_.add_trigger(trigger);
  return builder_.Finish();
}

struct ReportOrientedPoint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReportOrientedPointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORIENTED_LIST = 4
  };
  const flatbuffers::Vector<const swr::OrientedPoint *> *oriented_list() const {
    return GetPointer<const flatbuffers::Vector<const swr::OrientedPoint *> *>(VT_ORIENTED_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ORIENTED_LIST) &&
           verifier.VerifyVector(oriented_list()) &&
           verifier.EndTable();
  }
};

struct ReportOrientedPointBuilder {
  typedef ReportOrientedPoint Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_oriented_list(flatbuffers::Offset<flatbuffers::Vector<const swr::OrientedPoint *>> oriented_list) {
    fbb_.AddOffset(ReportOrientedPoint::VT_ORIENTED_LIST, oriented_list);
  }
  explicit ReportOrientedPointBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReportOrientedPointBuilder &operator=(const ReportOrientedPointBuilder &);
  flatbuffers::Offset<ReportOrientedPoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReportOrientedPoint>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReportOrientedPoint> CreateReportOrientedPoint(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const swr::OrientedPoint *>> oriented_list = 0) {
  ReportOrientedPointBuilder builder_(_fbb);
  builder_.add_oriented_list(oriented_list);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReportOrientedPoint> CreateReportOrientedPointDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<swr::OrientedPoint> *oriented_list = nullptr) {
  auto oriented_list__ = oriented_list ? _fbb.CreateVectorOfStructs<swr::OrientedPoint>(*oriented_list) : 0;
  return swr::CreateReportOrientedPoint(
      _fbb,
      oriented_list__);
}

struct ReportFaultCode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReportFaultCodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FAULT = 4
  };
  const swr::FaultCode *fault() const {
    return GetStruct<const swr::FaultCode *>(VT_FAULT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<swr::FaultCode>(verifier, VT_FAULT) &&
           verifier.EndTable();
  }
};

struct ReportFaultCodeBuilder {
  typedef ReportFaultCode Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fault(const swr::FaultCode *fault) {
    fbb_.AddStruct(ReportFaultCode::VT_FAULT, fault);
  }
  explicit ReportFaultCodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReportFaultCodeBuilder &operator=(const ReportFaultCodeBuilder &);
  flatbuffers::Offset<ReportFaultCode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReportFaultCode>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReportFaultCode> CreateReportFaultCode(
    flatbuffers::FlatBufferBuilder &_fbb,
    const swr::FaultCode *fault = 0) {
  ReportFaultCodeBuilder builder_(_fbb);
  builder_.add_fault(fault);
  return builder_.Finish();
}

struct ReportLockFaultCode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReportLockFaultCodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FAULT = 4
  };
  const swr::LockFaultCode *fault() const {
    return GetPointer<const swr::LockFaultCode *>(VT_FAULT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FAULT) &&
           verifier.VerifyTable(fault()) &&
           verifier.EndTable();
  }
};

struct ReportLockFaultCodeBuilder {
  typedef ReportLockFaultCode Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fault(flatbuffers::Offset<swr::LockFaultCode> fault) {
    fbb_.AddOffset(ReportLockFaultCode::VT_FAULT, fault);
  }
  explicit ReportLockFaultCodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReportLockFaultCodeBuilder &operator=(const ReportLockFaultCodeBuilder &);
  flatbuffers::Offset<ReportLockFaultCode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReportLockFaultCode>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReportLockFaultCode> CreateReportLockFaultCode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<swr::LockFaultCode> fault = 0) {
  ReportLockFaultCodeBuilder builder_(_fbb);
  builder_.add_fault(fault);
  return builder_.Finish();
}

struct ReportRobotEvent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReportRobotEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EVENT = 4
  };
  uint32_t event() const {
    return GetField<uint32_t>(VT_EVENT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_EVENT) &&
           verifier.EndTable();
  }
};

struct ReportRobotEventBuilder {
  typedef ReportRobotEvent Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_event(uint32_t event) {
    fbb_.AddElement<uint32_t>(ReportRobotEvent::VT_EVENT, event, 0);
  }
  explicit ReportRobotEventBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReportRobotEventBuilder &operator=(const ReportRobotEventBuilder &);
  flatbuffers::Offset<ReportRobotEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReportRobotEvent>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReportRobotEvent> CreateReportRobotEvent(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t event = 0) {
  ReportRobotEventBuilder builder_(_fbb);
  builder_.add_event(event);
  return builder_.Finish();
}

struct ReportSlamMapSendCompleted FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReportSlamMapSendCompletedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEND_COMPLETED = 4
  };
  bool send_completed() const {
    return GetField<uint8_t>(VT_SEND_COMPLETED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SEND_COMPLETED) &&
           verifier.EndTable();
  }
};

struct ReportSlamMapSendCompletedBuilder {
  typedef ReportSlamMapSendCompleted Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_send_completed(bool send_completed) {
    fbb_.AddElement<uint8_t>(ReportSlamMapSendCompleted::VT_SEND_COMPLETED, static_cast<uint8_t>(send_completed), 0);
  }
  explicit ReportSlamMapSendCompletedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReportSlamMapSendCompletedBuilder &operator=(const ReportSlamMapSendCompletedBuilder &);
  flatbuffers::Offset<ReportSlamMapSendCompleted> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReportSlamMapSendCompleted>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReportSlamMapSendCompleted> CreateReportSlamMapSendCompleted(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool send_completed = false) {
  ReportSlamMapSendCompletedBuilder builder_(_fbb);
  builder_.add_send_completed(send_completed);
  return builder_.Finish();
}

///////////////////////////////////////////
///////////////////////////////////////////
struct Report FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReportBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_DATA_TYPE = 6,
    VT_DATA = 8
  };
  swr::ReportType type() const {
    return static_cast<swr::ReportType>(GetField<int8_t>(VT_TYPE, 0));
  }
  swr::ReportDataField data_type() const {
    return static_cast<swr::ReportDataField>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const swr::ReportBlueTrigger *data_as_ReportBlueTrigger() const {
    return data_type() == swr::ReportDataField_ReportBlueTrigger ? static_cast<const swr::ReportBlueTrigger *>(data()) : nullptr;
  }
  const swr::ReportSelfTest *data_as_ReportSelfTest() const {
    return data_type() == swr::ReportDataField_ReportSelfTest ? static_cast<const swr::ReportSelfTest *>(data()) : nullptr;
  }
  const swr::ReportSelfTestProcess *data_as_ReportSelfTestProcess() const {
    return data_type() == swr::ReportDataField_ReportSelfTestProcess ? static_cast<const swr::ReportSelfTestProcess *>(data()) : nullptr;
  }
  const swr::ReportImage *data_as_ReportImage() const {
    return data_type() == swr::ReportDataField_ReportImage ? static_cast<const swr::ReportImage *>(data()) : nullptr;
  }
  const swr::ReportRosMap *data_as_ReportRosMap() const {
    return data_type() == swr::ReportDataField_ReportRosMap ? static_cast<const swr::ReportRosMap *>(data()) : nullptr;
  }
  const swr::ReportPose *data_as_ReportPose() const {
    return data_type() == swr::ReportDataField_ReportPose ? static_cast<const swr::ReportPose *>(data()) : nullptr;
  }
  const swr::ReportCleanTime *data_as_ReportCleanTime() const {
    return data_type() == swr::ReportDataField_ReportCleanTime ? static_cast<const swr::ReportCleanTime *>(data()) : nullptr;
  }
  const swr::ReportCleanArea *data_as_ReportCleanArea() const {
    return data_type() == swr::ReportDataField_ReportCleanArea ? static_cast<const swr::ReportCleanArea *>(data()) : nullptr;
  }
  const swr::ReportAutoClean *data_as_ReportAutoClean() const {
    return data_type() == swr::ReportDataField_ReportAutoClean ? static_cast<const swr::ReportAutoClean *>(data()) : nullptr;
  }
  const swr::ReportTitleBar *data_as_ReportTitleBar() const {
    return data_type() == swr::ReportDataField_ReportTitleBar ? static_cast<const swr::ReportTitleBar *>(data()) : nullptr;
  }
  const swr::ReportScanQR *data_as_ReportScanQR() const {
    return data_type() == swr::ReportDataField_ReportScanQR ? static_cast<const swr::ReportScanQR *>(data()) : nullptr;
  }
  const swr::ReportSiteInfo *data_as_ReportSiteInfo() const {
    return data_type() == swr::ReportDataField_ReportSiteInfo ? static_cast<const swr::ReportSiteInfo *>(data()) : nullptr;
  }
  const swr::ReportRouteInfo *data_as_ReportRouteInfo() const {
    return data_type() == swr::ReportDataField_ReportRouteInfo ? static_cast<const swr::ReportRouteInfo *>(data()) : nullptr;
  }
  const swr::ReportDownloadProgress *data_as_ReportDownloadProgress() const {
    return data_type() == swr::ReportDataField_ReportDownloadProgress ? static_cast<const swr::ReportDownloadProgress *>(data()) : nullptr;
  }
  const swr::ReportTestRealTimeStatus *data_as_ReportTestRealTimeStatus() const {
    return data_type() == swr::ReportDataField_ReportTestRealTimeStatus ? static_cast<const swr::ReportTestRealTimeStatus *>(data()) : nullptr;
  }
  const swr::ErrorCode *data_as_ErrorCode() const {
    return data_type() == swr::ReportDataField_ErrorCode ? static_cast<const swr::ErrorCode *>(data()) : nullptr;
  }
  const swr::ReportPerson *data_as_ReportPerson() const {
    return data_type() == swr::ReportDataField_ReportPerson ? static_cast<const swr::ReportPerson *>(data()) : nullptr;
  }
  const swr::ReportElevator *data_as_ReportElevator() const {
    return data_type() == swr::ReportDataField_ReportElevator ? static_cast<const swr::ReportElevator *>(data()) : nullptr;
  }
  const swr::ReportPowerDown *data_as_ReportPowerDown() const {
    return data_type() == swr::ReportDataField_ReportPowerDown ? static_cast<const swr::ReportPowerDown *>(data()) : nullptr;
  }
  const swr::ReportOrientedPoint *data_as_ReportOrientedPoint() const {
    return data_type() == swr::ReportDataField_ReportOrientedPoint ? static_cast<const swr::ReportOrientedPoint *>(data()) : nullptr;
  }
  const swr::ReportFaultCode *data_as_ReportFaultCode() const {
    return data_type() == swr::ReportDataField_ReportFaultCode ? static_cast<const swr::ReportFaultCode *>(data()) : nullptr;
  }
  const swr::ReportRobotEvent *data_as_ReportRobotEvent() const {
    return data_type() == swr::ReportDataField_ReportRobotEvent ? static_cast<const swr::ReportRobotEvent *>(data()) : nullptr;
  }
  const swr::ReportSlamMapSendCompleted *data_as_ReportSlamMapSendCompleted() const {
    return data_type() == swr::ReportDataField_ReportSlamMapSendCompleted ? static_cast<const swr::ReportSlamMapSendCompleted *>(data()) : nullptr;
  }
  const swr::ReportLockFaultCode *data_as_ReportLockFaultCode() const {
    return data_type() == swr::ReportDataField_ReportLockFaultCode ? static_cast<const swr::ReportLockFaultCode *>(data()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyReportDataField(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

template<> inline const swr::ReportBlueTrigger *Report::data_as<swr::ReportBlueTrigger>() const {
  return data_as_ReportBlueTrigger();
}

template<> inline const swr::ReportSelfTest *Report::data_as<swr::ReportSelfTest>() const {
  return data_as_ReportSelfTest();
}

template<> inline const swr::ReportSelfTestProcess *Report::data_as<swr::ReportSelfTestProcess>() const {
  return data_as_ReportSelfTestProcess();
}

template<> inline const swr::ReportImage *Report::data_as<swr::ReportImage>() const {
  return data_as_ReportImage();
}

template<> inline const swr::ReportRosMap *Report::data_as<swr::ReportRosMap>() const {
  return data_as_ReportRosMap();
}

template<> inline const swr::ReportPose *Report::data_as<swr::ReportPose>() const {
  return data_as_ReportPose();
}

template<> inline const swr::ReportCleanTime *Report::data_as<swr::ReportCleanTime>() const {
  return data_as_ReportCleanTime();
}

template<> inline const swr::ReportCleanArea *Report::data_as<swr::ReportCleanArea>() const {
  return data_as_ReportCleanArea();
}

template<> inline const swr::ReportAutoClean *Report::data_as<swr::ReportAutoClean>() const {
  return data_as_ReportAutoClean();
}

template<> inline const swr::ReportTitleBar *Report::data_as<swr::ReportTitleBar>() const {
  return data_as_ReportTitleBar();
}

template<> inline const swr::ReportScanQR *Report::data_as<swr::ReportScanQR>() const {
  return data_as_ReportScanQR();
}

template<> inline const swr::ReportSiteInfo *Report::data_as<swr::ReportSiteInfo>() const {
  return data_as_ReportSiteInfo();
}

template<> inline const swr::ReportRouteInfo *Report::data_as<swr::ReportRouteInfo>() const {
  return data_as_ReportRouteInfo();
}

template<> inline const swr::ReportDownloadProgress *Report::data_as<swr::ReportDownloadProgress>() const {
  return data_as_ReportDownloadProgress();
}

template<> inline const swr::ReportTestRealTimeStatus *Report::data_as<swr::ReportTestRealTimeStatus>() const {
  return data_as_ReportTestRealTimeStatus();
}

template<> inline const swr::ErrorCode *Report::data_as<swr::ErrorCode>() const {
  return data_as_ErrorCode();
}

template<> inline const swr::ReportPerson *Report::data_as<swr::ReportPerson>() const {
  return data_as_ReportPerson();
}

template<> inline const swr::ReportElevator *Report::data_as<swr::ReportElevator>() const {
  return data_as_ReportElevator();
}

template<> inline const swr::ReportPowerDown *Report::data_as<swr::ReportPowerDown>() const {
  return data_as_ReportPowerDown();
}

template<> inline const swr::ReportOrientedPoint *Report::data_as<swr::ReportOrientedPoint>() const {
  return data_as_ReportOrientedPoint();
}

template<> inline const swr::ReportFaultCode *Report::data_as<swr::ReportFaultCode>() const {
  return data_as_ReportFaultCode();
}

template<> inline const swr::ReportRobotEvent *Report::data_as<swr::ReportRobotEvent>() const {
  return data_as_ReportRobotEvent();
}

template<> inline const swr::ReportSlamMapSendCompleted *Report::data_as<swr::ReportSlamMapSendCompleted>() const {
  return data_as_ReportSlamMapSendCompleted();
}

template<> inline const swr::ReportLockFaultCode *Report::data_as<swr::ReportLockFaultCode>() const {
  return data_as_ReportLockFaultCode();
}

struct ReportBuilder {
  typedef Report Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(swr::ReportType type) {
    fbb_.AddElement<int8_t>(Report::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_data_type(swr::ReportDataField data_type) {
    fbb_.AddElement<uint8_t>(Report::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(flatbuffers::Offset<void> data) {
    fbb_.AddOffset(Report::VT_DATA, data);
  }
  explicit ReportBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReportBuilder &operator=(const ReportBuilder &);
  flatbuffers::Offset<Report> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Report>(end);
    return o;
  }
};

inline flatbuffers::Offset<Report> CreateReport(
    flatbuffers::FlatBufferBuilder &_fbb,
    swr::ReportType type = swr::ReportType_ReportBlueTrigger,
    swr::ReportDataField data_type = swr::ReportDataField_NONE,
    flatbuffers::Offset<void> data = 0) {
  ReportBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  builder_.add_type(type);
  return builder_.Finish();
}

inline bool VerifyReportTitleBarData(flatbuffers::Verifier &verifier, const void *obj, ReportTitleBarData type) {
  switch (type) {
    case ReportTitleBarData_NONE: {
      return true;
    }
    case ReportTitleBarData_ReportCloudState: {
      auto ptr = reinterpret_cast<const swr::ReportCloudState *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReportTitleBarData_ReportNetLevel: {
      auto ptr = reinterpret_cast<const swr::ReportNetLevel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReportTitleBarData_ReportBatteryLevel: {
      auto ptr = reinterpret_cast<const swr::ReportBatteryLevel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyReportTitleBarDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyReportTitleBarData(
        verifier,  values->Get(i), types->GetEnum<ReportTitleBarData>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyReportMarkerRLT(flatbuffers::Verifier &verifier, const void *obj, ReportMarkerRLT type) {
  switch (type) {
    case ReportMarkerRLT_NONE: {
      return true;
    }
    case ReportMarkerRLT_ReportDistinguishRLT: {
      auto ptr = reinterpret_cast<const swr::ReportDistinguishRLT *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReportMarkerRLT_ReportCalculateRLT: {
      auto ptr = reinterpret_cast<const swr::ReportCalculateRLT *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyReportMarkerRLTVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyReportMarkerRLT(
        verifier,  values->Get(i), types->GetEnum<ReportMarkerRLT>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyReportDataField(flatbuffers::Verifier &verifier, const void *obj, ReportDataField type) {
  switch (type) {
    case ReportDataField_NONE: {
      return true;
    }
    case ReportDataField_ReportBlueTrigger: {
      auto ptr = reinterpret_cast<const swr::ReportBlueTrigger *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReportDataField_ReportSelfTest: {
      auto ptr = reinterpret_cast<const swr::ReportSelfTest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReportDataField_ReportSelfTestProcess: {
      auto ptr = reinterpret_cast<const swr::ReportSelfTestProcess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReportDataField_ReportImage: {
      auto ptr = reinterpret_cast<const swr::ReportImage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReportDataField_ReportRosMap: {
      auto ptr = reinterpret_cast<const swr::ReportRosMap *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReportDataField_ReportPose: {
      auto ptr = reinterpret_cast<const swr::ReportPose *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReportDataField_ReportCleanTime: {
      auto ptr = reinterpret_cast<const swr::ReportCleanTime *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReportDataField_ReportCleanArea: {
      auto ptr = reinterpret_cast<const swr::ReportCleanArea *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReportDataField_ReportAutoClean: {
      auto ptr = reinterpret_cast<const swr::ReportAutoClean *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReportDataField_ReportTitleBar: {
      auto ptr = reinterpret_cast<const swr::ReportTitleBar *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReportDataField_ReportScanQR: {
      auto ptr = reinterpret_cast<const swr::ReportScanQR *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReportDataField_ReportSiteInfo: {
      auto ptr = reinterpret_cast<const swr::ReportSiteInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReportDataField_ReportRouteInfo: {
      auto ptr = reinterpret_cast<const swr::ReportRouteInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReportDataField_ReportDownloadProgress: {
      auto ptr = reinterpret_cast<const swr::ReportDownloadProgress *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReportDataField_ReportTestRealTimeStatus: {
      auto ptr = reinterpret_cast<const swr::ReportTestRealTimeStatus *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReportDataField_ErrorCode: {
      auto ptr = reinterpret_cast<const swr::ErrorCode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReportDataField_ReportPerson: {
      auto ptr = reinterpret_cast<const swr::ReportPerson *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReportDataField_ReportElevator: {
      auto ptr = reinterpret_cast<const swr::ReportElevator *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReportDataField_ReportPowerDown: {
      auto ptr = reinterpret_cast<const swr::ReportPowerDown *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReportDataField_ReportOrientedPoint: {
      auto ptr = reinterpret_cast<const swr::ReportOrientedPoint *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReportDataField_ReportFaultCode: {
      auto ptr = reinterpret_cast<const swr::ReportFaultCode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReportDataField_ReportRobotEvent: {
      auto ptr = reinterpret_cast<const swr::ReportRobotEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReportDataField_ReportSlamMapSendCompleted: {
      auto ptr = reinterpret_cast<const swr::ReportSlamMapSendCompleted *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ReportDataField_ReportLockFaultCode: {
      auto ptr = reinterpret_cast<const swr::ReportLockFaultCode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyReportDataFieldVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyReportDataField(
        verifier,  values->Get(i), types->GetEnum<ReportDataField>(i))) {
      return false;
    }
  }
  return true;
}

inline const swr::Report *GetReport(const void *buf) {
  return flatbuffers::GetRoot<swr::Report>(buf);
}

inline const swr::Report *GetSizePrefixedReport(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<swr::Report>(buf);
}

inline bool VerifyReportBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<swr::Report>(nullptr);
}

inline bool VerifySizePrefixedReportBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<swr::Report>(nullptr);
}

inline void FinishReportBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<swr::Report> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedReportBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<swr::Report> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace swr

#endif  // FLATBUFFERS_GENERATED_REPORT_SWR_H_
