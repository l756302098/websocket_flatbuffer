// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_S2C_ABBY_H_
#define FLATBUFFERS_GENERATED_S2C_ABBY_H_

#include "flatbuffers/flatbuffers.h"

namespace abby {

struct ServerA;
struct ServerABuilder;
struct ServerAT;

struct ServerB;
struct ServerBBuilder;
struct ServerBT;

struct ServerC;
struct ServerCBuilder;
struct ServerCT;

struct ServerData;
struct ServerDataBuilder;
struct ServerDataT;

enum ServerType : uint8_t {
  ServerType_NONE = 0,
  ServerType_ServerA = 1,
  ServerType_ServerB = 2,
  ServerType_ServerC = 3,
  ServerType_MIN = ServerType_NONE,
  ServerType_MAX = ServerType_ServerC
};

inline const ServerType (&EnumValuesServerType())[4] {
  static const ServerType values[] = {
    ServerType_NONE,
    ServerType_ServerA,
    ServerType_ServerB,
    ServerType_ServerC
  };
  return values;
}

inline const char * const *EnumNamesServerType() {
  static const char * const names[5] = {
    "NONE",
    "ServerA",
    "ServerB",
    "ServerC",
    nullptr
  };
  return names;
}

inline const char *EnumNameServerType(ServerType e) {
  if (flatbuffers::IsOutRange(e, ServerType_NONE, ServerType_ServerC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesServerType()[index];
}

template<typename T> struct ServerTypeTraits {
  static const ServerType enum_value = ServerType_NONE;
};

template<> struct ServerTypeTraits<abby::ServerA> {
  static const ServerType enum_value = ServerType_ServerA;
};

template<> struct ServerTypeTraits<abby::ServerB> {
  static const ServerType enum_value = ServerType_ServerB;
};

template<> struct ServerTypeTraits<abby::ServerC> {
  static const ServerType enum_value = ServerType_ServerC;
};

struct ServerTypeUnion {
  ServerType type;
  void *value;

  ServerTypeUnion() : type(ServerType_NONE), value(nullptr) {}
  ServerTypeUnion(ServerTypeUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(ServerType_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ServerTypeUnion(const ServerTypeUnion &);
  ServerTypeUnion &operator=(const ServerTypeUnion &u)
    { ServerTypeUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ServerTypeUnion &operator=(ServerTypeUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ServerTypeUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = ServerTypeTraits<typename RT::TableType>::enum_value;
    if (type != ServerType_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, ServerType type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  abby::ServerAT *AsServerA() {
    return type == ServerType_ServerA ?
      reinterpret_cast<abby::ServerAT *>(value) : nullptr;
  }
  const abby::ServerAT *AsServerA() const {
    return type == ServerType_ServerA ?
      reinterpret_cast<const abby::ServerAT *>(value) : nullptr;
  }
  abby::ServerBT *AsServerB() {
    return type == ServerType_ServerB ?
      reinterpret_cast<abby::ServerBT *>(value) : nullptr;
  }
  const abby::ServerBT *AsServerB() const {
    return type == ServerType_ServerB ?
      reinterpret_cast<const abby::ServerBT *>(value) : nullptr;
  }
  abby::ServerCT *AsServerC() {
    return type == ServerType_ServerC ?
      reinterpret_cast<abby::ServerCT *>(value) : nullptr;
  }
  const abby::ServerCT *AsServerC() const {
    return type == ServerType_ServerC ?
      reinterpret_cast<const abby::ServerCT *>(value) : nullptr;
  }
};

bool VerifyServerType(flatbuffers::Verifier &verifier, const void *obj, ServerType type);
bool VerifyServerTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct ServerAT : public flatbuffers::NativeTable {
  typedef ServerA TableType;
  double price = 0.0;
  std::string name{};
};

struct ServerA FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerAT NativeTableType;
  typedef ServerABuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PRICE = 4,
    VT_NAME = 6
  };
  double price() const {
    return GetField<double>(VT_PRICE, 0.0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_PRICE) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
  ServerAT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ServerAT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ServerA> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ServerAT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ServerABuilder {
  typedef ServerA Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_price(double price) {
    fbb_.AddElement<double>(ServerA::VT_PRICE, price, 0.0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ServerA::VT_NAME, name);
  }
  explicit ServerABuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ServerA> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerA>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerA> CreateServerA(
    flatbuffers::FlatBufferBuilder &_fbb,
    double price = 0.0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  ServerABuilder builder_(_fbb);
  builder_.add_price(price);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<ServerA> CreateServerADirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double price = 0.0,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return abby::CreateServerA(
      _fbb,
      price,
      name__);
}

flatbuffers::Offset<ServerA> CreateServerA(flatbuffers::FlatBufferBuilder &_fbb, const ServerAT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ServerBT : public flatbuffers::NativeTable {
  typedef ServerB TableType;
  std::string name{};
  int32_t age = 0;
};

struct ServerB FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerBT NativeTableType;
  typedef ServerBBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_AGE = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t age() const {
    return GetField<int32_t>(VT_AGE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_AGE) &&
           verifier.EndTable();
  }
  ServerBT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ServerBT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ServerB> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ServerBT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ServerBBuilder {
  typedef ServerB Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ServerB::VT_NAME, name);
  }
  void add_age(int32_t age) {
    fbb_.AddElement<int32_t>(ServerB::VT_AGE, age, 0);
  }
  explicit ServerBBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ServerB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerB>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerB> CreateServerB(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t age = 0) {
  ServerBBuilder builder_(_fbb);
  builder_.add_age(age);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<ServerB> CreateServerBDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int32_t age = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return abby::CreateServerB(
      _fbb,
      name__,
      age);
}

flatbuffers::Offset<ServerB> CreateServerB(flatbuffers::FlatBufferBuilder &_fbb, const ServerBT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ServerCT : public flatbuffers::NativeTable {
  typedef ServerC TableType;
  std::string name{};
  int32_t weight = 0;
};

struct ServerC FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerCT NativeTableType;
  typedef ServerCBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_WEIGHT = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t weight() const {
    return GetField<int32_t>(VT_WEIGHT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_WEIGHT) &&
           verifier.EndTable();
  }
  ServerCT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ServerCT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ServerC> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ServerCT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ServerCBuilder {
  typedef ServerC Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ServerC::VT_NAME, name);
  }
  void add_weight(int32_t weight) {
    fbb_.AddElement<int32_t>(ServerC::VT_WEIGHT, weight, 0);
  }
  explicit ServerCBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ServerC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerC>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerC> CreateServerC(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t weight = 0) {
  ServerCBuilder builder_(_fbb);
  builder_.add_weight(weight);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<ServerC> CreateServerCDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int32_t weight = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return abby::CreateServerC(
      _fbb,
      name__,
      weight);
}

flatbuffers::Offset<ServerC> CreateServerC(flatbuffers::FlatBufferBuilder &_fbb, const ServerCT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ServerDataT : public flatbuffers::NativeTable {
  typedef ServerData TableType;
  abby::ServerTypeUnion message{};
};

struct ServerData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerDataT NativeTableType;
  typedef ServerDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  abby::ServerType message_type() const {
    return static_cast<abby::ServerType>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const abby::ServerA *message_as_ServerA() const {
    return message_type() == abby::ServerType_ServerA ? static_cast<const abby::ServerA *>(message()) : nullptr;
  }
  const abby::ServerB *message_as_ServerB() const {
    return message_type() == abby::ServerType_ServerB ? static_cast<const abby::ServerB *>(message()) : nullptr;
  }
  const abby::ServerC *message_as_ServerC() const {
    return message_type() == abby::ServerType_ServerC ? static_cast<const abby::ServerC *>(message()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyServerType(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
  ServerDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ServerDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ServerData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ServerDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const abby::ServerA *ServerData::message_as<abby::ServerA>() const {
  return message_as_ServerA();
}

template<> inline const abby::ServerB *ServerData::message_as<abby::ServerB>() const {
  return message_as_ServerB();
}

template<> inline const abby::ServerC *ServerData::message_as<abby::ServerC>() const {
  return message_as_ServerC();
}

struct ServerDataBuilder {
  typedef ServerData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(abby::ServerType message_type) {
    fbb_.AddElement<uint8_t>(ServerData::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(ServerData::VT_MESSAGE, message);
  }
  explicit ServerDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ServerData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerData> CreateServerData(
    flatbuffers::FlatBufferBuilder &_fbb,
    abby::ServerType message_type = abby::ServerType_NONE,
    flatbuffers::Offset<void> message = 0) {
  ServerDataBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

flatbuffers::Offset<ServerData> CreateServerData(flatbuffers::FlatBufferBuilder &_fbb, const ServerDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ServerAT *ServerA::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ServerAT>(new ServerAT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ServerA::UnPackTo(ServerAT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = price(); _o->price = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
}

inline flatbuffers::Offset<ServerA> ServerA::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ServerAT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateServerA(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ServerA> CreateServerA(flatbuffers::FlatBufferBuilder &_fbb, const ServerAT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ServerAT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _price = _o->price;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  return abby::CreateServerA(
      _fbb,
      _price,
      _name);
}

inline ServerBT *ServerB::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ServerBT>(new ServerBT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ServerB::UnPackTo(ServerBT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = age(); _o->age = _e; }
}

inline flatbuffers::Offset<ServerB> ServerB::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ServerBT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateServerB(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ServerB> CreateServerB(flatbuffers::FlatBufferBuilder &_fbb, const ServerBT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ServerBT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _age = _o->age;
  return abby::CreateServerB(
      _fbb,
      _name,
      _age);
}

inline ServerCT *ServerC::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ServerCT>(new ServerCT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ServerC::UnPackTo(ServerCT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = weight(); _o->weight = _e; }
}

inline flatbuffers::Offset<ServerC> ServerC::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ServerCT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateServerC(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ServerC> CreateServerC(flatbuffers::FlatBufferBuilder &_fbb, const ServerCT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ServerCT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _weight = _o->weight;
  return abby::CreateServerC(
      _fbb,
      _name,
      _weight);
}

inline ServerDataT *ServerData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ServerDataT>(new ServerDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ServerData::UnPackTo(ServerDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = message_type(); _o->message.type = _e; }
  { auto _e = message(); if (_e) _o->message.value = abby::ServerTypeUnion::UnPack(_e, message_type(), _resolver); }
}

inline flatbuffers::Offset<ServerData> ServerData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ServerDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateServerData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ServerData> CreateServerData(flatbuffers::FlatBufferBuilder &_fbb, const ServerDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ServerDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _message_type = _o->message.type;
  auto _message = _o->message.Pack(_fbb);
  return abby::CreateServerData(
      _fbb,
      _message_type,
      _message);
}

inline bool VerifyServerType(flatbuffers::Verifier &verifier, const void *obj, ServerType type) {
  switch (type) {
    case ServerType_NONE: {
      return true;
    }
    case ServerType_ServerA: {
      auto ptr = reinterpret_cast<const abby::ServerA *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerType_ServerB: {
      auto ptr = reinterpret_cast<const abby::ServerB *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerType_ServerC: {
      auto ptr = reinterpret_cast<const abby::ServerC *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyServerTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyServerType(
        verifier,  values->Get(i), types->GetEnum<ServerType>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ServerTypeUnion::UnPack(const void *obj, ServerType type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case ServerType_ServerA: {
      auto ptr = reinterpret_cast<const abby::ServerA *>(obj);
      return ptr->UnPack(resolver);
    }
    case ServerType_ServerB: {
      auto ptr = reinterpret_cast<const abby::ServerB *>(obj);
      return ptr->UnPack(resolver);
    }
    case ServerType_ServerC: {
      auto ptr = reinterpret_cast<const abby::ServerC *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> ServerTypeUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case ServerType_ServerA: {
      auto ptr = reinterpret_cast<const abby::ServerAT *>(value);
      return CreateServerA(_fbb, ptr, _rehasher).Union();
    }
    case ServerType_ServerB: {
      auto ptr = reinterpret_cast<const abby::ServerBT *>(value);
      return CreateServerB(_fbb, ptr, _rehasher).Union();
    }
    case ServerType_ServerC: {
      auto ptr = reinterpret_cast<const abby::ServerCT *>(value);
      return CreateServerC(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ServerTypeUnion::ServerTypeUnion(const ServerTypeUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case ServerType_ServerA: {
      value = new abby::ServerAT(*reinterpret_cast<abby::ServerAT *>(u.value));
      break;
    }
    case ServerType_ServerB: {
      value = new abby::ServerBT(*reinterpret_cast<abby::ServerBT *>(u.value));
      break;
    }
    case ServerType_ServerC: {
      value = new abby::ServerCT(*reinterpret_cast<abby::ServerCT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ServerTypeUnion::Reset() {
  switch (type) {
    case ServerType_ServerA: {
      auto ptr = reinterpret_cast<abby::ServerAT *>(value);
      delete ptr;
      break;
    }
    case ServerType_ServerB: {
      auto ptr = reinterpret_cast<abby::ServerBT *>(value);
      delete ptr;
      break;
    }
    case ServerType_ServerC: {
      auto ptr = reinterpret_cast<abby::ServerCT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = ServerType_NONE;
}

inline const abby::ServerData *GetServerData(const void *buf) {
  return flatbuffers::GetRoot<abby::ServerData>(buf);
}

inline const abby::ServerData *GetSizePrefixedServerData(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<abby::ServerData>(buf);
}

inline bool VerifyServerDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<abby::ServerData>(nullptr);
}

inline bool VerifySizePrefixedServerDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<abby::ServerData>(nullptr);
}

inline void FinishServerDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<abby::ServerData> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedServerDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<abby::ServerData> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<abby::ServerDataT> UnPackServerData(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<abby::ServerDataT>(GetServerData(buf)->UnPack(res));
}

inline std::unique_ptr<abby::ServerDataT> UnPackSizePrefixedServerData(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<abby::ServerDataT>(GetSizePrefixedServerData(buf)->UnPack(res));
}

}  // namespace abby

#endif  // FLATBUFFERS_GENERATED_S2C_ABBY_H_
